{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Andy's Notes on Interesting Topics Encountered Throughout My Embedded Engineering Career","text":"<p>Welcome to the Andy's Notes! This site is a collection of notes, insights, and lessons learned throughout my journey as an embedded engineer. It covers a wide range of topics, including software development, hardware design, and system-level concepts essential to building reliable and efficient embedded systems.</p>"},{"location":"#sections","title":"Sections","text":"<ul> <li>Automotive</li> <li>Cyber Security</li> <li>Digital Systems Design</li> <li>Physics</li> <li>Signals and Systems</li> </ul>"},{"location":"Automotive/pages/","title":"Overview","text":"<ul> <li>Vehicle Electrical/Electronic Architecture</li> <li>Sensors and Signals</li> </ul>"},{"location":"Automotive/pages/architecture/","title":"Vehicle Electrical/Electronic Architecture","text":"<p>Vehicle Electrical/Electronic (E/E) architecture refers to the overall design and integration of a vehicle's electrical and electronic systems, encompassing hardware, software, and communication networks. It defines how components such as sensors, actuators, electronic control units (ECUs), wiring, and communication protocols (e.g., CAN, LIN, Ethernet) are organized and interconnected to enable vehicle functionality. Modern E/E architectures are evolving to support increasing system complexity, including advanced driver-assistance systems (ADAS), infotainment, and electrification, while meeting stringent requirements for performance, scalability, safety, and cybersecurity.</p>"},{"location":"Automotive/pages/architecture/#electronic-control-units-ecus","title":"Electronic Control Units (ECUs)","text":"<p>An Electronic Control Unit (ECU) is an embedded system within automotive electronics that manages a system or task in a vehicle. ECUs act as the brains processing sensory or other relevant data to send control signals to actuators and interfaces. Like most embedded systems, ECUs can take many hardware forms such as microcontrollers, microprocessors, ASICs, and FPGAs.</p>"},{"location":"Automotive/pages/architecture/#automotive-domains","title":"Automotive domains","text":"<p>A domain refers to a system typically composed of a collection of ECUs and their subordinate systems, working together to perform a specific vehicle-level function. What a domain is and which electronics belong in each domain can vary depending on who you ask and the specifics of the vehicle, especially as vehicles become more complex and interconnected over time. Below is how Dr. Ahmad MK Nasser breaks down the domains and provides some example ECUs/Modules for each. I added some images from seperate sources to help visualize these domains.Notice how the images don't line up with Dr. Ahmad's example ECUs, automotive electronics changes wildly depending on the specific vehicle type, manufacturer, model, trim, and even specific factories.</p>"},{"location":"Automotive/pages/architecture/#fuel-based-powertrain-domain","title":"Fuel-Based Powertrain Domain","text":"<p>This domain manages internal combustion engines (ICEs), focusing on tasks such as engine performance, gear shifting, and emissions control.</p> <ul> <li>Engine Control Module (ECM): Regulates engine functions, including ignition timing, fuel injection, and engine cooling</li> <li>Transmission Control Module (TCM): Optimizes gear shifting in automatic transmissions by analyzing input data such as engine speed, vehicle speed, throttle position</li> </ul>"},{"location":"Automotive/pages/architecture/#electric-drive-powertrain-domain","title":"Electric Drive Powertrain Domain","text":"<p>This domain handles battery management and electric motor control in electric vehicles (EVs).</p> <ul> <li>Battery Management System (BMS): Monitors the state of charge (SoC) and state of health (SoH), and ensures battery safety and thermal management.</li> <li>Powertrain Electronic Control Unit (PECU): Manages motor speed and acceleration, and controls voltage and frequency supplied to the motor.</li> </ul>"},{"location":"Automotive/pages/architecture/#chassis-safety-control-domain","title":"Chassis Safety Control Domain","text":"<p>The chassis domain ensures vehicle stability and safety through active and passive safety systems.</p> <ul> <li>Electronic Braking Control Module (EBCM): Provides functions like ABS, ESC, and emergency braking.</li> <li>Electronic Power Steering (EPS): Assists steering and enables lane correction.</li> <li>Airbag Control Module: Deploys airbags during collisions for passenger safety.</li> <li>Advanced Driver Assistance (ADAS) control module: In modern vehicles, a dedicated ECU is often used to achieve advanced levels of autonomy, even though some ADAS functions can be integrated into the EBCM and EPS. This specialized module coordinates with the ECM, EBCM, and EPS to manage engine torque, braking, and steering as required by the situation. By processing inputs from various sensors, the ADAS ECU enables features like autonomous highway driving and automated parking, among other autonomy functions.</li> </ul>"},{"location":"Automotive/pages/architecture/#interior-cabin-domain","title":"Interior Cabin Domain","text":"<p>This domain focuses on comfort, convenience, and security features.</p> <ul> <li>Body Control Module (BCM): Controls keyless entry, seat adjustments, and lighting.</li> <li>Climate Control Module (CCM): Manages cabin heating, cooling, and ventilation.</li> </ul>"},{"location":"Automotive/pages/architecture/#infotainment-and-connectivity-domain","title":"Infotainment and Connectivity Domain","text":"<p>This domain integrates driver and passenger-facing interfaces, focusing on entertainment and connectivity. As you would expect, this domain is becoming increasing significant to electronics engineers due to advancments in V2X communications.</p> <ul> <li>In-Vehicle Infotainment (IVI): Provides entertainment, navigation, and driver information.</li> <li>Telematics Control Unit (TCU): Facilitates GPS, remote connectivity, and over-the-air (OTA) updates.</li> </ul>"},{"location":"Automotive/pages/architecture/#cross-domain-communication","title":"Cross-Domain Communication","text":"<p>Cross-domain functionality provides a reliable communication framework for inter-domain message exchange.</p> <ul> <li>Central Gateway (CGW): Acts as an in-vehicle router, enabling communication across different network segments (e.g., CAN to Ethernet) and supporting cybersecurity measures to block unwanted traffic.</li> </ul>"},{"location":"Automotive/pages/architecture/#vehicle-architecture-types","title":"Vehicle Architecture Types","text":"<p>The design of a vehicle's electrical and electronic (E/E) architecture significantly impacts functionality, security, and resource usage. Over time, E/E architectures have evolved from highly distributed systems to more centralized configurations, aiming to consolidate vehicle functions and enhance computational power. This evolution can be categorized into three main types: highly distributed architectures, domain-centralized architectures, and zone architectures.</p> <p>Note: Vehicle manufacturers (OEMs) may adopt different approaches to evolving their E/E architectures. As a result, some vehicles may feature hybrid architectures that are transitional stages between the types described here. The evolution of vehicle E/E architecture is ongoing, and new architectural classes may emerge in the future.</p>"},{"location":"Automotive/pages/architecture/#highly-distributed-ee-architecture","title":"Highly Distributed E/E Architecture","text":"<p>In a highly distributed architecture, Electronic Control Units (ECUs) are grouped based on similar or interdependent functionalities within shared network segments. Communication protocols such as Controller Area Network (CAN), Local Interconnect Network (LIN), or FlexRay facilitate message exchange between these ECUs. This architecture enables direct mapping between vehicle functions and specific ECUs.</p> <p>However, the addition of new functionalities often requires local gateways to relay messages between network segments (e.g., CAN to LIN). While this allows for scalability without a complete network redesign, it introduces vulnerabilities. Gateways may fail to isolate network segments effectively, increasing the risk of unauthorized access to critical ECUs. Additionally, ECUs with varying levels of security exposure\u2014such as infotainment systems and safety-critical ECUs like braking systems\u2014may be grouped together, heightening security risks.</p> <p>The On-Board Diagnostics (OBD) connector also presents a potential security issue. It is typically connected directly to internal network segments, such as the powertrain or chassis domains, providing a potential entry point for attackers.</p>"},{"location":"Automotive/pages/architecture/#domain-centralized-ee-architecture","title":"Domain-Centralized E/E Architecture","text":"<p>The domain-centralized E/E architecture addresses the challenges of cost, maintenance, and security seen in highly distributed systems. In this configuration, ECUs are grouped into well-defined domains (e.g., powertrain, chassis, infotainment, and body), and communication between these domains is managed through dedicated gateways.</p> <p>A central gateway equipped with a high-speed Ethernet backbone serves as the communication hub, enabling high-bandwidth data transfer across domains. This setup supports advanced features like Diagnostics over IP (DoIP), allowing parallel flashing and diagnostics of multiple ECUs. The gateway enforces network filtering rules, improving security by isolating domains from unauthorized access.</p> <p>By consolidating multiple ECUs into domain-specific controllers, this architecture simplifies maintenance, reduces complexity, and enhances overall security by minimizing the attack surface.</p>"},{"location":"Automotive/pages/architecture/#zone-architecture","title":"Zone Architecture","text":"<p>Zone architecture represents the next step in E/E architecture evolution. This configuration employs powerful vehicle computers or zone ECUs, which connect directly to sensors and actuators within specific physical areas of the vehicle. This design reduces the total number of ECUs, enhances computational efficiency, and simplifies network structures.</p> <p>Zone architectures improve scalability and flexibility while providing robust security. Functions are isolated within distinct zones, making it easier to implement security controls and monitor communications. This design supports advanced features such as autonomous driving and over-the-air updates, meeting the demands of modern vehicles.</p>"},{"location":"Automotive/pages/architecture/#references","title":"References","text":"<ol> <li>Ahmad MK Nasser, Automotive Cybersecurity Engineering Handbook.</li> </ol>"},{"location":"Automotive/pages/architecture/#image-sources","title":"Image Sources","text":"<ol> <li>Electric Drive Powertrain Domain: https://evreporter.com/ev-powertrain-components/</li> <li>Fuel-Based Powertrain Domain: https://afdc.energy.gov/files/vehicles/flexfuel-high-res.jpg</li> <li>Chassis Safety Control Domai: https://www.automotivesafetycouncil.org/wp-content/uploads/2017/01/air-bag-sensor-car-layout-700x441.jpg</li> <li>Interior Cabin Domain: https://d17ocfn2f5o4rl.cloudfront.net/wp-content/uploads/2019/01/In-car-electronics-controlled-via-BCM.jpg</li> <li>Infotainment and Connectivity Domain: https://www.tek.com/en/blog/taking-in-vehicle-infotainment-into-the-future</li> <li>Vehicle Architecture Types: Ahmad MK Nasser, Automotive Cybersecurity Engineering Handbook.</li> </ol>"},{"location":"Automotive/pages/sensorsSignals/","title":"External Automotive Sensors and Signals","text":"<p>Modern vehicles integrate a variety of sensors to interact with their external environment. These sensors are critical for safety, efficiency, and comfort. Below is a description of key external sensors, their functionalities, and the data they provide.</p>"},{"location":"Automotive/pages/sensorsSignals/#vision-based-sensors","title":"Vision-Based Sensors","text":""},{"location":"Automotive/pages/sensorsSignals/#cameras","title":"Cameras","text":"<p>Cameras capture visual data for various applications. They are used for digital rear-view mirrors, traffic sign recognition, surround view systems, and lane-keeping assistance.</p> <p>Operation: Cameras detect light on a photosensitive surface using a lens and process the data into images for use by ECUs. They typically support 8 MP resolution at 60 FPS, use GMSL links for data transmission at rates up to 6 GB/s, and are often configured via I2C.</p> <p>Risks: Interference can lead to misidentification of objects or privacy violations.</p>"},{"location":"Automotive/pages/sensorsSignals/#infrared-sensors","title":"Infrared Sensors","text":"<p>Infrared sensors detect heat signatures, improving visibility in low-light conditions.</p> <p>Applications: Night vision systems, pedestrian detection, and animal detection.</p> <p>Operation: Detect emitted infrared radiation and process it into thermal images.</p> <p>Risks: Sensor obfuscation can reduce visibility.</p>"},{"location":"Automotive/pages/sensorsSignals/#proximity-and-object-detection-sensors","title":"Proximity and Object Detection Sensors","text":""},{"location":"Automotive/pages/sensorsSignals/#lidar-light-detection-and-ranging","title":"LiDAR (Light Detection and Ranging)","text":"<p>LiDAR generates 3D spatial maps by emitting laser pulses. It is used for object detection and classification, as well as autonomous navigation.</p> <p>Operation: Measures time-of-flight of laser pulses to calculate distances and interfaces with the host ECU via 1000Base-T1 Ethernet.</p> <p>Risks: Tampering can disrupt object detection and compromise safety systems.</p>"},{"location":"Automotive/pages/sensorsSignals/#radar-radio-detection-and-ranging","title":"RADAR (Radio Detection and Ranging)","text":"<p>RADAR detects objects using electromagnetic waves. It is applied in adaptive cruise control, collision avoidance, and blind-spot monitoring.</p> <p>Operation: Measures range and speed using the Doppler effect and connects to the host ECU via CAN or Ethernet.</p> <p>Risks: Jamming or spoofing can impact obstacle detection.</p>"},{"location":"Automotive/pages/sensorsSignals/#ultrasonic-sensors","title":"Ultrasonic Sensors","text":"<p>Ultrasonic sensors detect nearby objects using high-frequency sound waves. They are commonly used for parking assistance and proximity alerts.</p> <p>Operation: Emit sound waves and calculate the distance based on reflected echoes. They communicate with the ECU via CAN.</p> <p>Risks: Signal interference can compromise obstacle detection.</p>"},{"location":"Automotive/pages/sensorsSignals/#communication-and-navigation-systems","title":"Communication and Navigation Systems","text":""},{"location":"Automotive/pages/sensorsSignals/#vehicle-to-everything-v2x-communication","title":"Vehicle-to-Everything (V2X) Communication","text":"<p>V2X communication enables interaction between vehicles, infrastructure, and other road users.</p> <p>Applications: Traffic management and collision prevention.</p> <p>Operation: Uses DSRC or cellular networks for wireless data exchange.</p> <p>Risks: Cyberattacks can compromise communication reliability.</p>"},{"location":"Automotive/pages/sensorsSignals/#telematics-systems","title":"Telematics Systems","text":"<p>Telematics systems integrate GPS, cellular communication, and sensors to enable real-time data exchange with remote servers.</p> <p>Applications: Fleet management, remote diagnostics, over-the-air (OTA) updates, and stolen vehicle recovery.</p> <p>Operation: Collects data from sensors like GPS and speedometers, sends it to cloud servers via cellular networks, and allows bidirectional communication for remote management.</p> <p>Risks: Data breaches can expose sensitive information, and communication hijacking can lead to unauthorized vehicle control or tracking.</p>"},{"location":"Automotive/pages/sensorsSignals/#gnss-global-navigation-satellite-system","title":"GNSS (Global Navigation Satellite System)","text":"<p>GNSS provides location, velocity, and timing information. It is used for navigation, geofencing, and route optimization.</p> <p>Operation: Receives satellite signals to determine position and interfaces with the host ECU via CAN or UART.</p> <p>Risks: Spoofing or jamming can disrupt localization and timing.</p>"},{"location":"Automotive/pages/sensorsSignals/#access-and-monitoring-systems","title":"Access and Monitoring Systems","text":""},{"location":"Automotive/pages/sensorsSignals/#passive-keyless-entry-pke-and-remote-keyless-entry-rke","title":"Passive Keyless Entry (PKE) and Remote Keyless Entry (RKE)","text":"<p>PKE and RKE systems enable automatic vehicle access and remote locking/unlocking.</p> <p>Operation: PKE detects key proximity using low-frequency (LF) and ultra-high frequency (UHF) signals, while RKE uses RF signals for remote interaction.</p> <p>Risks: Relay attacks can exploit vulnerabilities in signal transmission.</p>"},{"location":"Automotive/pages/sensorsSignals/#tire-pressure-monitoring-system-tpms","title":"Tire Pressure Monitoring System (TPMS)","text":"<p>TPMS monitors tire pressure to ensure safety and efficiency.</p> <p>Operation: Sensors transmit pressure data wirelessly to the ECU, typically at 315 MHz or 433 MHz.</p> <p>Risks: Signal spoofing can result in false alerts or undetected issues.</p>"},{"location":"Automotive/pages/sensorsSignals/#summary","title":"Summary","text":"<p>These external sensors and systems form the backbone of modern vehicles, enabling advanced functionalities and ensuring safety. Grouping and understanding their roles, communication methods, and potential vulnerabilities is critical for optimizing performance and securing operations.</p>"},{"location":"Cybersecurity/pages/","title":"Overview","text":""},{"location":"Cybersecurity/pages/#resources","title":"Resources","text":"<p>CERT Coding Standards</p>"},{"location":"DSD/","title":"Digital System Design","text":"<p>Digital System Design (DSD) focuses on creating and implementing digital systems using hardware description languages (HDLs) like Verilog and VHDL. It involves designing, simulating, and optimizing combinational and sequential circuits for tasks such as data processing, communication, and control. DSD bridges the gap between theoretical logic design and practical hardware implementation, enabling the development of complex digital systems like processors, controllers, and FPGA-based solutions.</p> <ul> <li>Verilog Basics</li> <li>Logic Design</li> <li>Simulations</li> <li>Applications and Examples</li> </ul>"},{"location":"DSD/#resources","title":"Resources","text":"<p>I worked on several engaging projects for the Nexys A7 Board, focusing on tasks such as handling inputs from buttons, switches, and PWM signals. These projects showcase computations and outputs via hex displays, VGA, and PWM control. You can download a zip file containing all the projects here: DSD Lab Projects</p> <p>Lab reports and Homework</p>"},{"location":"DSD/applications/","title":"Applications and Examples","text":""},{"location":"DSD/applications/#4-bit-adder","title":"4-bit Adder","text":"<p>A 4-bit adder adds two 4-bit binary numbers together, producing a 4-bit sum output along with a carry-out bit that indicates an overflow if the sum exceeds the capacity of 4 bits.</p> <p></p>"},{"location":"DSD/applications/#ripple-carry-adder-rca","title":"Ripple Carry Adder (RCA)","text":"<pre><code>module FullAdder (A, B, Ci, Co, S);\n\n    input A, B, Ci;    // Inputs: A, B, and Carry In (Ci)\n    output S, Co;      // Outputs: Sum (S) and Carry Out (Co)\n\n    assign S = A ^ B ^ Ci;      // Sum calculation\n    assign Co = (A &amp; B) | (B &amp; Ci) | (A &amp; Ci);  // Carry Out calculation\n\nendmodule\n\n\nmodule Adder4 (S, Co, A, B, Ci);\n\n    input [3:0] A, B;  // 4-bit inputs\n    input Ci;          // Carry input\n    output [3:0] S;    // 4-bit sum output\n    output Co;         // Carry out\n    wire [3:1] C;      // Internal carry signals\n\n    // Instantiate 4 Full Adders\n    FullAdder FA0 (A[0], B[0], Ci, C[1], S[0]);\n    FullAdder FA1 (A[1], B[1], C[1], C[2], S[1]);\n    FullAdder FA2 (A[2], B[2], C[2], C[3], S[2]);\n    FullAdder FA3 (A[3], B[3], C[3], Co, S[3]);\n\nendmodule\n</code></pre>"},{"location":"DSD/applications/#look-ahead-adder-cla","title":"Look-Ahead Adder (CLA)","text":"<p>A 4-bit carry look-ahead adder (CLA) is a faster alternative to the ripple carry adder, as it calculates the carries in parallel rather than waiting for each carry to propagate through the stages sequentially. The carry look-ahead adder computes the carry signals using the generate (G) and propagate (P) functions.</p> <pre><code>module cla_4bit (\n    input [3:0] A, B,\n    input Cin,\n    output [3:0] Sum,\n    output Cout\n);\n    wire [3:0] G, P;  // Generate and propagate signals\n    wire C1, C2, C3;\n\n    // Generate and propagate signals\n    assign G = A &amp; B;  // Generate\n    assign P = A | B;  // Propagate\n\n    // Carry look-ahead logic\n    assign #5 C1 = G[0] | (P[0] &amp; Cin);\n    assign #5 C2 = G[1] | (P[1] &amp; G[0]) | (P[1] &amp; P[0] &amp; Cin);\n    assign #5 C3 = G[2] | (P[2] &amp; G[1]) | (P[2] &amp; P[1] &amp; G[0]) | (P[2] &amp; P[1] &amp; P[0] &amp; Cin);\n    assign #5 Cout = G[3] | (P[3] &amp; G[2]) | (P[3] &amp; P[2] &amp; G[1]) | (P[3] &amp; P[2] &amp; P[1] &amp; G[0]) | (P[3] &amp; P[2] &amp; P[1] &amp; P[0] &amp; Cin);\n\n    // Sum calculation\n    assign #5 Sum[0] = A[0] ^ B[0] ^ Cin;\n    assign #5 Sum[1] = A[1] ^ B[1] ^ C1;\n    assign #5 Sum[2] = A[2] ^ B[2] ^ C2;\n    assign #5 Sum[3] = A[3] ^ B[3] ^ C3;\n\nendmodule\n</code></pre>"},{"location":"DSD/applications/#delay-comparison-carry-look-ahead-adder-cla-vs-ripple-carry-adder-rca","title":"Delay Comparison: Carry Look-Ahead Adder (CLA) vs. Ripple Carry Adder (RCA)","text":""},{"location":"DSD/applications/#1-ripple-carry-adder-rca","title":"1. Ripple Carry Adder (RCA)","text":"<ul> <li>Delay Growth: Linear <code>O(N)</code> (increases with the number of bits)</li> <li>Total Delay: <code>N * Gate Delay per Full Adder</code></li> </ul>"},{"location":"DSD/applications/#2-carry-look-ahead-adder-cla","title":"2. Carry Look-Ahead Adder (CLA)","text":"<ul> <li>Delay Growth: Logarithmic <code>O(log N)</code> (grows slower as the number of bits increases)</li> <li>Total Delay: <code>log_2(N) * Gate Delay per Stage</code></li> </ul>"},{"location":"DSD/applications/#3-comparison-of-delays","title":"3. Comparison of Delays","text":"Number of Bits RCA Delay (Linear) CLA Delay (Logarithmic) 4 bits 20 ns 20 ns 8 bits 40 ns 15 ns 16 bits 80 ns 20 ns 32 bits 160 ns 25 ns 64 bits 320 ns 30 ns"},{"location":"DSD/applications/#4-to-1-mux","title":"4-to-1 Mux","text":"<p>A 4-to-1 multiplexer selects one of four input signals based on a 2-bit selection input and forwards the selected input to the output.</p> <p></p> <pre><code>module Mux4to1 (\n    input wire I0, I1, I2, I3,  // 4 data inputs\n    input wire S0, S1,          // 2 select lines\n    output wire Y               // Output\n);\n\nassign Y = (~S1 &amp; ~S0 &amp; I0) |  // Select I0 when S1 = 0, S0 = 0\n           (~S1 &amp;  S0 &amp; I1) |  // Select I1 when S1 = 0, S0 = 1\n           ( S1 &amp; ~S0 &amp; I2) |  // Select I2 when S1 = 1, S0 = 0\n           ( S1 &amp;  S0 &amp; I3);   // Select I3 when S1 = 1, S0 = 1\n\nendmodule\n</code></pre>"},{"location":"DSD/applications/#shift-register","title":"Shift Register","text":""},{"location":"DSD/applications/#4-bit-left-shift","title":"4-bit Left Shift","text":"<p>A 4-bit left shift register shifts the contents of the register one bit to the left on each clock cycle, with a new bit introduced at the least significant bit (LSB) and the most significant bit (MSB) being discarded.</p> <p></p> <pre><code>module LeftShiftRegister (\n    input wire clk,           // Clock input\n    input wire reset,         // Reset input\n    input wire D_in,          // Serial data input\n    output reg [3:0] Q        // 4-bit parallel output\n);\n\n// On the positive edge of the clock, perform the left shift\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        Q &lt;= 4'b0000;         // Reset all outputs to 0\n    end else begin\n        Q &lt;= {Q[2:0], D_in};  // Shift left and input new data bit on Q0\n    end\nend\n\nendmodule\n</code></pre>"},{"location":"DSD/applications/#8-bit-left-shift","title":"8-bit Left Shift","text":"<pre><code>module shift_register_8bit (\n    input wire SI,     // Serial input\n    input wire Clk,    // Clock signal (rising edge)\n    input wire EN,     // Enable (active high)\n    output reg SO      // Serial output\n);\n\n    // Internal 8-bit register to hold the shift data\n    reg [7:0] shift_reg;\n\n    // Always block triggered on rising edge of clock\n    always @(posedge Clk) begin\n        if (EN) begin\n            // Shift register: shift in SI and shift out MSB (SO)\n            SO &lt;= shift_reg[7];      // MSB is shifted out\n            shift_reg &lt;= {shift_reg[6:0], SI};  // Shift left and input SI\n        end\n    end\n\nendmodule\n</code></pre>"},{"location":"DSD/applications/#8-bit-counter-lab-3","title":"8-bit Counter (Lab 3)","text":"<p>Lab simulation: 3-Bit Up/Down counter with a clear and load.</p> <p>This lab involves designing an 8-bit up/down counter using Verilog, implemented on the NEXYS-4 FPGA board. A Vivado project is provided for this example.</p> <p>The CD74HC190/191 and CD54HC190/191 are highly versatile presettable up/down counters commonly used in digital electronics for tasks requiring accurate counting, such as digital clocks, timers, and frequency dividers. These ICs can be configured to count in either binary (CD74HC191) or BCD (Binary-Coded Decimal) format (CD74HC190), and support synchronous counting with a variety of control options, including asynchronous presetting, counting direction control, and enabling inputs. With additional outputs like ripple carry and terminal count, these counters are ideal for cascading multiple units to create larger counting systems.</p> <p>In Lab 3, we implemented an 8-bit up/down counter based on the functionality of the 74HC190/191 but directly in Verilog, bypassing the need for discrete hardware. This allowed us to overcome common design challenges such as signal ripple effects and cascading hazards that typically occur when connecting multiple 4-bit counters. By using Verilog, we streamlined the design, implementing advanced features such as parallel loading, which enables the counter to start from a user-defined value, and a clock control to slow down the counting process for easier observation.</p>"},{"location":"DSD/applications/#identifying-required-number-of-bits","title":"Identifying Required Number of bits","text":"<p>To determine how many bits are needed to count to a specific number \\(N\\), use the following steps:</p> <ol> <li>Use the formula: <code>n = log2(N)</code> where <code>n</code> is the number of bits.</li> <li>Round up the result to the nearest whole number.</li> <li>A counter with <code>n</code> bits can represent numbers from <code>0</code> to <code>2^n - 1</code>, which must be greater than or equal to \\(N\\).</li> </ol>"},{"location":"DSD/applications/#example","title":"Example:","text":"<p>To count up to 100:</p> <ol> <li><code>n = log2(100)</code> \u2248 6.64</li> <li>Round up to 7.</li> </ol> <p>You would need 7 bits to count up to 100, as 7 bits can represent values from 0 to 127.</p>"},{"location":"DSD/applications/#parallel-loading","title":"Parallel Loading","text":"<p>Parallel loading allows a counter to load a preset value into all its flip-flops simultaneously in a single clock cycle. By using input lines (like A-D or D0-D3) and a load signal, the counter can instantly update its value upon the next clock cycle, bypassing the need for sequential counting. This is particularly useful for initializing the counter or synchronizing multiple counters efficiently. In this lab, we used parallel loading to preset the 8-bit counter with values determined by the input switches, adding greater flexibility to the counting process.</p>"},{"location":"DSD/applications/#synchronous-4-bit-updown-counter-74hc192","title":"Synchronous 4-bit Up/Down Counter (74HC192)","text":"<pre><code>module counter_74HC192 (\n    input wire Clr,      // Clear the counter\n    input wire Load,     // Load the counter with a value\n    input wire Up,       // Count up when asserted\n    input wire Down,     // Count down when asserted\n    input wire [3:0] P,  // Data input for loading preset\n    input wire Clk,      // Clock input\n    output reg [3:0] Q   // 4-bit counter output\n);\n\n// Always block, sensitive to Clk, Clr, Load, Up, Down\nalways @(posedge Clk or posedge Clr or posedge Load) begin\n    if (Clr) begin\n        Q &lt;= 4'b0000;  // Clear the counter\n    end\n    else if (Load) begin\n        Q &lt;= D;  // Load the counter with input value\n    end\n    else if (Up &amp;&amp; !Down) begin\n        Q &lt;= Q + 1;  // Increment counter\n    end\n    else if (Down &amp;&amp; !Up) begin\n        Q &lt;= Q - 1;  // Decrement counter\n    end\nend\n\nendmodule\n</code></pre>"},{"location":"DSD/applications/#sr-latch","title":"SR Latch","text":""},{"location":"DSD/applications/#sr-latch-using-a-boolean-equation","title":"SR Latch Using a Boolean Equation","text":"<pre><code>module sr_latch_boolean (\n    input wire S,   // Set input\n    input wire R,   // Reset input\n    output reg Q,   // Output\n    output reg Qn   // Inverted output\n);\n\n    always @(*) begin\n        if (S &amp;&amp; !R) begin\n            Q &lt;= 1;   // Set\n            Qn &lt;= 0;\n        end\n        else if (!S &amp;&amp; R) begin\n            Q &lt;= 0;   // Reset\n            Qn &lt;= 1;\n        end\n        // If S == 0 and R == 0, Q and Qn retain previous state (no action)\n    end\n\nendmodule\n</code></pre>"},{"location":"DSD/applications/#sr-latch-using-gate-level-description","title":"SR Latch Using Gate-Level Description","text":"<pre><code>module sr_latch_gate_level (\n    input wire S,   // Set input\n    input wire R,   // Reset input\n    output wire Q,  // Output\n    output wire Qn  // Inverted output\n);\n\n    wire nand1_out, nand2_out;\n\n    // NAND gates for SR Latch\n    nand (nand1_out, S, Qn);  // First NAND gate\n    nand (nand2_out, R, Q);   // Second NAND gate\n\n    assign Q = nand1_out;\n    assign Qn = nand2_out;\n\nendmodule\n</code></pre>"},{"location":"DSD/applications/#4-bit-comparator","title":"4-bit Comparator","text":"<p>A 4-bit comparator is a digital circuit that compares two 4-bit binary numbers and outputs the result of their comparison. It determines whether one number is greater than, less than, or equal to the other.</p>"},{"location":"DSD/applications/#inputs","title":"Inputs","text":"<ul> <li>A[3:0]: 4-bit binary number (A3, A2, A1, A0)</li> <li>B[3:0]: 4-bit binary number (B3, B2, B1, B0)</li> </ul>"},{"location":"DSD/applications/#outputs","title":"Outputs","text":"<ul> <li>A &gt; B: Output is 1 if the binary number A is greater than B.</li> <li>A &lt; B: Output is 1 if the binary number A is less than B.</li> <li>A = B: Output is 1 if the binary number A is equal to B.</li> </ul>"},{"location":"DSD/applications/#logic-for-comparison","title":"Logic for Comparison","text":"<p>To compare two 4-bit numbers, the comparison starts from the most significant bit (MSB) down to the least significant bit (LSB):</p> <ol> <li>A &gt; B:</li> <li>If A3 &gt; B3, then A &gt; B regardless of the lower bits.</li> <li>If A3 = B3, move to compare A2 and B2.</li> <li> <p>Repeat for all bits until a difference is found or A = B.</p> </li> <li> <p>A &lt; B:</p> </li> <li>If A3 &lt; B3, then A &lt; B.</li> <li>If A3 = B3, move to compare A2 and B2.</li> <li> <p>Continue this until a difference is found or A = B.</p> </li> <li> <p>A = B:</p> </li> <li>If all bits (A3 to A0) are equal to their corresponding B bits, then A = B.</li> </ol>"},{"location":"DSD/applications/#truth-table","title":"Truth Table","text":"A3 A2 A1 A0 B3 B2 B1 B0 A &gt; B A &lt; B A = B 0 0 0 1 0 0 0 1 0 0 1 1 0 1 0 0 1 1 0 1 0 0 0 1 1 1 1 0 0 1 0 1 0 ... ... ... ... ... ... ... ... ... ... ..."},{"location":"DSD/applications/#verilog-implementation","title":"Verilog Implementation","text":"<p>A simple implementation in Verilog:</p> <pre><code>module Comparator4bit(\n    input [3:0] A, B,\n    output A_greater, A_less, A_equal\n);\n\nassign A_greater = (A &gt; B);\nassign A_less = (A &lt; B);\nassign A_equal = (A == B);\n\nendmodule\n</code></pre>"},{"location":"DSD/dsd_old/","title":"Digital System Design","text":""},{"location":"DSD/dsd_old/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Verilog Basics<ul> <li>Data Types</li> <li>Vectors in Verilog</li> <li>Primitives</li> <li>Verilog Operator Precednece</li> <li>Shifts</li> <li>Functions and Tasks</li> </ul> </li> <li>Logic Design<ul> <li>Boolean Algebra</li> <li>Sequential and Combinational Assignments</li> <li>State Machines</li> </ul> </li> <li>Simulations<ul> <li>Delays in Verilog</li> <li>Wait Statements</li> </ul> </li> <li>Applications<ul> <li>4-bit Adder</li> <li>4-to-1 Mux</li> <li>Left Shift Register</li> <li>8 Bit Counter (Lab 3)</li> <li>Synchronous 4-bit Up/Down Counter</li> <li>SR Latch</li> </ul> </li> <li>Nexys A7</li> <li>To Do</li> </ul>"},{"location":"DSD/dsd_old/#verilog-basics","title":"Verilog Basics","text":""},{"location":"DSD/dsd_old/#data-types","title":"Data Types","text":"Data Type Purpose Characteristics <code>wire</code> Combinational logic and connections Cannot hold state, used in continuous assignments <code>reg</code> Sequential and combinational logic Holds state, used inside <code>always</code> blocks <code>integer</code> Signed 32-bit value for loops/counters Used in loops and non-synthesizable code <code>real</code> Floating-point value Used in non-synthesizable, behavioral code <code>time</code> 64-bit value to represent simulation time Used for timing and measuring delays in simulation <code>tri</code> Tri-state buffer signal Can take high-impedance (<code>Z</code>) values"},{"location":"DSD/dsd_old/#vectors-in-verilog","title":"Vectors in Verilog","text":"<p>Vectors in Verilog are used to represent multi-bit signals, which are crucial when dealing with buses, registers, or large numbers. They allow for grouping multiple bits into a single variable.</p> <p>A vector is declared by specifying the range of bits using <code>[MSB:LSB]</code>, where MSB is the most significant bit and LSB is the least significant bit.</p> <pre><code>wire [3:0] bus;   // 4-bit wide wire (vector)\nreg  [7:0] data;  // 8-bit register\n</code></pre> <p>Individual bits or a range of bits within a vector can be accessed as follows:</p> <pre><code>wire [7:0] data;\nassign bit3 = data[3];     // Accessing the 3rd bit of data\nassign lower_nibble = data[3:0];  // Accessing the lower 4 bits of data\n</code></pre> <p>You can assign values directly to vectors:</p> <pre><code>reg [3:0] result;\nresult = 4'b1010;  // Assigning binary value\nresult = 4'hA;     // Assigning hexadecimal value\n</code></pre> <p>A vector can have zero width when the MSB and LSB are the same, meaning it's a single-bit signal:</p> <pre><code>wire [0:0] single_bit;  // Equivalent to a scalar\n</code></pre> <p>By default, vectors are unsigned, but they can be declared as signed if needed:</p> <pre><code>signed reg [7:0] signed_data;  // Signed 8-bit register\n</code></pre> <p>In signed vectors, the most significant bit (MSB) is treated as the sign bit.</p>"},{"location":"DSD/dsd_old/#primitives","title":"Primitives","text":"<p>A Verilog primitive is a pre-defined logic element used in digital designs. These include basic gates like <code>and</code>, <code>or</code>, <code>nand</code>, and <code>xor</code>, with fixed functions that don't require module definitions.</p> <p>Output Declaration: In Verilog, when declaring a UDP, the output must always be listed first, followed by the input(s). This order is essential for the proper functioning of the UDP.</p> <p>Types of Primitives: - Combinational Primitives: e.g., <code>and</code>, <code>or</code>, <code>xor</code> - Sequential Primitives: Flip-flops, latches</p>"},{"location":"DSD/dsd_old/#user-defined-primitives-udps","title":"User Defined Primitives (UDPs)","text":"<p>UDPs are custom-defined logic, either combinational or sequential, declared using the <code>primitive</code> keyword. They use a truth table to define behavior.</p> <ul> <li>Example (Combinational UDP):     ```verilog<pre><code>primitive my_and (out, in1, in2);  \noutput out;  \ninput in1, in2;\n\n// The 'table' defines the behavior of this custom primitive.\n// Each row in the table specifies input combinations and the corresponding output.\n// For an AND gate, the output is 1 only when both inputs are 1.\ntable\n    0 0 : 0;  // If both inputs are 0, the output is 0.\n    1 1 : 1;  // If both inputs are 1, the output is 1.\n    // For simplicity, intermediate input states (like 0 1 or 1 0) are not explicitly defined here,\n    // but in a full AND gate implementation, these would typically output 0.\nendtable\n\nendprimitive\n</code></pre> <p>```</p> </li> </ul>"},{"location":"DSD/dsd_old/#verilog-operator-precedence","title":"Verilog Operator Precedence","text":"<p>In Verilog, operators follow a specific order of precedence. This determines how expressions are evaluated when there are multiple operators in the same expression. Below is the list of operators in order of precedence, from highest to lowest:</p> <ol> <li>Unary operators</li> <li><code>+</code>, <code>-</code> (unary plus and minus)</li> <li><code>!</code> (logical NOT)</li> <li><code>~</code> (bitwise NOT)</li> <li><code>&amp;</code>, <code>~&amp;</code> (reduction AND, NAND)</li> <li><code>|</code>, <code>~|</code> (reduction OR, NOR)</li> <li> <p><code>^</code>, <code>~^</code>, <code>^~</code> (reduction XOR, XNOR)</p> </li> <li> <p>Multiplicative operators</p> </li> <li> <p><code>*</code>, <code>/</code>, <code>%</code> (multiply, divide, modulus)</p> </li> <li> <p>Additive operators</p> </li> <li> <p><code>+</code>, <code>-</code> (addition, subtraction)</p> </li> <li> <p>Shift operators</p> </li> <li> <p><code>&lt;&lt;</code>, <code>&gt;&gt;</code> (logical shift left, right)</p> </li> <li> <p>Relational operators</p> </li> <li> <p><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> (less than, less than or equal, greater than, greater than or equal)</p> </li> <li> <p>Equality operators</p> </li> <li><code>==</code>, <code>!=</code> (logical equality, inequality)</li> <li> <p><code>===</code>, <code>!==</code> (case equality, case inequality)</p> </li> <li> <p>Bitwise operators</p> </li> <li> <p><code>&amp;</code>, <code>|</code>, <code>^</code>, <code>^~</code>, <code>~^</code> (AND, OR, XOR, XNOR)</p> </li> <li> <p>Logical operators</p> </li> <li><code>&amp;&amp;</code> (logical AND)</li> <li> <p><code>||</code> (logical OR)</p> </li> <li> <p>Conditional operator</p> </li> <li> <p><code>? :</code> (ternary operator)</p> </li> <li> <p>Assignment operators</p> <ul> <li><code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&amp;=</code>, <code>|=</code>, <code>^=</code> (assignment and compound assignments)</li> </ul> </li> </ol>"},{"location":"DSD/dsd_old/#shifts","title":"Shifts","text":"<p>In Verilog, shift operations move bits of a value to the left or right. There are two types: logical shifts and arithmetic shifts.</p>"},{"location":"DSD/dsd_old/#1-logical-shifts","title":"1. Logical Shifts","text":"<p>Logical shifts move bits and fill the vacated positions with zeros.</p> <p>a. Logical Left Shift (<code>&lt;&lt;</code>) Shifts bits to the left by the specified amount, inserting zeros on the right. This is equivalent to multiplying by a power of 2.</p> <p>Syntax:</p> <pre><code>result = value &lt;&lt; shift_amount;\n</code></pre> <p>Example:</p> <pre><code>wire [3:0] value = 4'b1010; \nassign result = value &lt;&lt; 1;  // Result: 0100\n</code></pre> <p>b. Logical Right Shift (<code>&gt;&gt;</code>) Shifts bits to the right, inserting zeros on the left.</p> <p>Syntax:</p> <pre><code>result = value &gt;&gt; shift_amount;\n</code></pre> <p>Example:</p> <pre><code>wire [3:0] value = 4'b1010;\nassign result = value &gt;&gt; 1;  // Result: 0101\n</code></pre>"},{"location":"DSD/dsd_old/#2-arithmetic-shifts","title":"2. Arithmetic Shifts","text":"<p>Arithmetic shifts preserve the sign of signed numbers when shifting right.</p> <p>a. Arithmetic Right Shift (<code>&gt;&gt;&gt;</code>) Shifts bits to the right, preserving the sign by filling the leftmost bits with the sign bit (MSB).</p> <p>Syntax:</p> <pre><code>result = value &gt;&gt;&gt; shift_amount;\n</code></pre> <p>Example:</p> <pre><code>wire signed [3:0] value = -4;  // Binary: 1100 (two's complement)\nassign result = value &gt;&gt;&gt; 1;   // Result: 1110\n</code></pre>"},{"location":"DSD/dsd_old/#functions-and-tasks","title":"Functions and Tasks","text":"Aspect Functions Tasks Return Type Returns a single value. Can return multiple values via <code>output</code> ports. Time Control No timing control (<code>#</code>, <code>@</code>, <code>wait</code> not allowed). Supports timing control (can use <code>#</code>, <code>@</code>, <code>wait</code>). Arguments Only <code>input</code> arguments. Can have <code>input</code>, <code>output</code>, and <code>inout</code> arguments. Usage Used in expressions directly. Called as a separate statement. Execution Time Executes in zero simulation time. Takes simulation time to execute. Use Case Simple, combinational calculations. Complex tasks with delays or multiple outputs."},{"location":"DSD/dsd_old/#example-function","title":"Example Function:","text":"<pre><code>function [3:0] add;\n  input [3:0] a, b;\n  begin\n    add = a + b;\n  end\nendfunction\n</code></pre>"},{"location":"DSD/dsd_old/#example-task","title":"Example Task:","text":"<pre><code>task add_sub;\n  input [3:0] a, b;\n  output [3:0] sum, diff;\n  begin\n    sum = a + b;\n    diff = a - b;\n  end\nendtask\n</code></pre>"},{"location":"DSD/dsd_old/#example-task-with-event-control","title":"Example Task (With Event Control):","text":"<pre><code>task event_control_example;\n  input [3:0] a, b;\n  output reg [3:0] result;\n  begin\n    wait (a == b);   // Wait until a equals b\n    result = a + b;  // Perform addition\n  end\nendtask\n</code></pre>"},{"location":"DSD/dsd_old/#example-task-with-output-and-inout-arguments-called-as-a-separate-statement","title":"Example Task (with <code>output</code> and <code>inout</code> Arguments Called as a Separate Statement):","text":"<pre><code>module task_example;\n  reg [3:0] x, y, z, sum_result, diff_result;\n\n  initial begin\n    x = 4'b1010;              // Assign some values\n    y = 4'b0110;\n    z = 4'b0011;\n\n    // Call the task as a separate statement\n    arithmetic_operations(x, y, sum_result, z);  // `z` will be modified in-place as an inout\n  end\nendmodule\n\ntask arithmetic_operations;\n  input [3:0] a, b;           // Input arguments\n  output reg [3:0] sum;       // Output argument\n  inout [3:0] diff;           // Inout argument\n  begin\n    sum = a + b;              // Perform addition\n    diff = diff - a;          // Modify the inout value\n  end\nendtask\n</code></pre>"},{"location":"DSD/dsd_old/#logic-design","title":"Logic Design","text":""},{"location":"DSD/dsd_old/#boolean-algebra","title":"Boolean Algebra","text":"Rule Expression Hint Identity Law A + 0 = A No change when OR'ed with 0 Identity Law A \u2022 1 = A No change when AND'ed with 1 Null Law A + 1 = 1 OR'ing with 1 results in 1 Null Law A \u2022 0 = 0 AND'ing with 0 results in 0 Complement Law A + A' = 1 A variable OR'ed with its complement is 1 Complement Law A \u2022 A' = 0 A variable AND'ed with its complement is 0 Idempotent Law A + A = A OR'ing a variable with itself leaves it unchanged Idempotent Law A \u2022 A = A AND'ing a variable with itself leaves it unchanged Domination Law A + A'B = A + B Apply the Distributive Law to simplify Distributive Law A(B + C) = AB + AC Distributes AND over OR Distributive Law A + BC = (A + B)(A + C) Distributes OR over AND Absorption Law A + AB = A Removes redundant terms Absorption Law A(A + B) = A Removes redundant terms Double Negation Law (A')' = A Negation of a negation returns the original value De Morgan\u2019s Law (A \u2022 B)' = A' + B' Apply to break AND terms when converting SOP to POS De Morgan\u2019s Law (A + B)' = A' \u2022 B' Apply to break OR terms when converting POS to SOP Involution Law (A'') = A A variable twice negated is equal to itself Consensus Theorem AB + A'C + BC = AB + A'C Simplifies expressions by eliminating redundant terms Distributive (SOP to POS hint) A + BC = (A + B)(A + C) Useful for converting SOP to POS Distributive (POS to SOP hint) A(B + C) = AB + AC Useful for converting POS to SOP Demorgans (SOP to POS hint) (A \u2022 B)' = A' + B' Apply De Morgan\u2019s Law during the conversion Demorgans (POS to SOP hint) (A + B)' = A' \u2022 B' Apply De Morgan\u2019s Law during the conversion Redundancy Law AB + AB' = A Removes redundant variables from the equation"},{"location":"DSD/dsd_old/#sequential-and-combinational-assignments","title":"Sequential and Combinational Assignments","text":"<ul> <li>Sequential = Procedural: Sequential logic updates state based on clock edges and uses procedural assignments, typically with non-blocking (<code>&lt;=</code>) assignments. It is modeled inside <code>always</code> blocks that are sensitive to clock edges (e.g., <code>posedge clk</code>). This describes systems like flip-flops or registers that rely on previous states.</li> </ul> <p>Example: <code>verilog   always @(posedge clk or posedge reset) begin       if (reset)           q &lt;= 0;      // Asynchronous reset       else           q &lt;= d;      // Update q with d at clock edge   end</code></p> <ul> <li> <p>Combinational = Continuous: Combinational logic depends purely on the current inputs and is described using continuous (blocking) assignments. It models circuits like AND, OR gates, where output is updated as soon as inputs change, without regard to clock cycles.</p> <p>Example: <code>verilog assign y = a &amp; b;  // Output y changes immediately based on a and b</code></p> </li> </ul>"},{"location":"DSD/dsd_old/#relevant-constructs","title":"Relevant Constructs","text":"<ul> <li> <p><code>always</code> blocks: Used to describe both sequential and combinational logic. For sequential logic, <code>always @(posedge clk)</code> or <code>always @(negedge clk)</code> is used, whereas for combinational logic, <code>always @(*)</code> is used to capture all input changes automatically.     Example: <code>verilog     always @(*) begin         result = a | b;  // Combinational logic triggered by any input change     end</code></p> </li> <li> <p><code>initial</code> blocks: Used to define initial conditions in simulations. They execute once at the start of the simulation and are commonly used for testbenches or initializing registers/variables in simulation but are not synthesized into hardware.     Example <code>verilog     initial begin         reg_x = 0;  // Initialize reg_x to 0 at simulation start     end</code></p> </li> </ul>"},{"location":"DSD/dsd_old/#key-points","title":"Key Points","text":"<ul> <li>Blocking (<code>=</code>) vs. Non-blocking (<code>&lt;=</code>): In sequential logic (<code>always @(posedge clk)</code>), use non-blocking assignments (<code>&lt;=</code>) to ensure parallel updates. In combinational logic, blocking assignments (<code>=</code>) can be used to execute statements sequentially.</li> </ul>"},{"location":"DSD/dsd_old/#state-machine","title":"State Machine","text":"<p>A state machine is a computational model used to design both software and hardware systems. It consists of a set of states, transitions between states, and actions that occur based on inputs.</p>"},{"location":"DSD/dsd_old/#components","title":"Components","text":"<ol> <li>States: Defined conditions or situations the system can be in.</li> <li>Transitions: Conditions that trigger a change from one state to another.</li> <li>Inputs: External events or conditions that affect state transitions.</li> <li>Outputs: Actions or results produced during or after a state transition.</li> </ol>"},{"location":"DSD/dsd_old/#types-of-state-machines","title":"Types of State Machines","text":"<ol> <li>Finite State Machine (FSM): Has a finite number of states and transitions between them.</li> <li>Deterministic FSM (DFA): Every state has exactly one transition for each input.</li> <li> <p>Non-deterministic FSM (NFA): A state can have multiple transitions for the same input.</p> </li> <li> <p>Mealy Machine: The output depends on both the current state and the input.</p> </li> <li>Moore Machine: The output depends only on the current state.</li> </ol>"},{"location":"DSD/dsd_old/#applications","title":"Applications","text":"<ul> <li>Control Systems: Used in embedded systems for managing device behavior.</li> <li>Protocols: Helps in defining the sequence of operations in communication protocols.</li> <li>Game Design: To model different game states such as playing, paused, or game over.</li> </ul>"},{"location":"DSD/dsd_old/#example","title":"Example","text":"<pre><code>module fsm_example (\n    input wire clk,        // Clock input\n    input wire reset,      // Asynchronous reset signal (active high)\n    input wire trigger,    // Trigger input to transition between states\n    output reg out         // Output signal that depends on the current state\n);\n\n    // Define the states as an enumerated type using a 2-bit register\n    typedef enum reg [1:0] {\n        IDLE   = 2'b00,    // State 0: Idle state (default)\n        STATE1 = 2'b01,    // State 1: Represents the first active state\n        STATE2 = 2'b10     // State 2: Represents the second active state\n    } state_t;\n\n    // Current state and next state registers\n    reg state_t current_state, next_state;\n\n    // Sequential logic for state transition\n    // This block updates the current state on every clock edge or reset\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state &lt;= IDLE;   // On reset, go to IDLE state\n        end else begin\n            current_state &lt;= next_state;  // On clock, update to the next state\n        end\n    end\n\n    // Combinational logic for state transition based on current state and input trigger\n    always @(*) begin\n        // Default next state and output values\n        next_state = current_state; // Hold the current state by default\n        out = 1'b0;                 // Default output is 0\n\n        // State transition logic\n        case (current_state)\n            IDLE: begin\n                // In IDLE, if 'trigger' is high, move to STATE1\n                if (trigger)\n                    next_state = STATE1;\n                // Output remains 0 in IDLE\n            end\n\n            STATE1: begin\n                // In STATE1, set output high\n                out = 1'b1;\n                // If 'trigger' is high, move to STATE2, otherwise go back to IDLE\n                if (trigger)\n                    next_state = STATE2;\n                else\n                    next_state = IDLE;\n            end\n\n            STATE2: begin\n                // In STATE2, output remains high\n                out = 1'b1;\n                // If 'trigger' goes low, return to IDLE\n                if (!trigger)\n                    next_state = IDLE;\n            end\n\n            default: begin\n                // Default case to handle any undefined state (shouldn't happen)\n                next_state = IDLE; // Return to IDLE state if something goes wrong\n            end\n        endcase\n    end\n\nendmodule\n</code></pre>"},{"location":"DSD/dsd_old/#simulations","title":"Simulations","text":""},{"location":"DSD/dsd_old/#delays-in-verilog","title":"Delays in Verilog","text":"<p>Propagation delays in Verilog simulate the time it takes for signals to propagate through circuits.</p>"},{"location":"DSD/dsd_old/#delayed-assignments","title":"Delayed Assignments","text":"<p>In continuous assignments, use <code>#delay</code> to specify how long it takes for the output to update after a change in the inputs.</p> <pre><code> assign #5 y = a &amp; b;  // y updates 5 time units after a or b changes \n ```\n\n### Why Use Delays?\n\n- **Timing Simulation:** Models real-world signal delays.\n- **Accurate Behavior:** Ensures proper timing in combinational logic.\n\n### Delays in Procedural Assignments\n\nDelays can also be applied in **procedural blocks** like `always`:\n\n```verilog\n always @ (a or b) begin\n    #3 out = a &amp; b;  // out updates 3 time units after input changes\nend \n</code></pre>"},{"location":"DSD/dsd_old/#inertial-vs-transport-delays","title":"Inertial vs. Transport Delays","text":"<ul> <li>Inertial Delay: This is the default type of delay in Verilog. It filters out glitches, meaning only input pulses longer than the delay propagate to the output. </li> <li>Example: If <code>#5</code> is used, pulses shorter than 5 time units will be filtered.</li> </ul> <p><code>verilog   assign #5 y = a &amp; b;  // Inertial delay, y updates only if changes persist for 5 time units</code></p> <ul> <li>Transport Delay: This models a physical delay without filtering any input pulses. Even if an input changes rapidly, the signal is propagated to the output after the delay.</li> <li>Example: Use <code>transport</code> to force transport delay behavior.</li> </ul> <p><code>verilog   assign #5 y = transport a &amp; b;  // Transport delay, y updates exactly 5 time units after input change</code></p>"},{"location":"DSD/dsd_old/#key-differences","title":"Key Differences:","text":"<ul> <li>Inertial delay: Mimics real-world circuits where short glitches are filtered.</li> <li>Transport delay: Models pure signal propagation without glitch filtering.</li> </ul>"},{"location":"DSD/dsd_old/#wait-statements","title":"Wait Statements","text":"<p>In Verilog, the <code>wait</code> statement is used to pause the execution of a block until a certain condition becomes true. Unlike an <code>always</code> or <code>@(posedge clk)</code> block that waits for specific events (like clock edges), the <code>wait</code> statement halts the execution until the specified condition is met. Primarily used with delays to simulate hardware restrictions.</p>"},{"location":"DSD/dsd_old/#syntax","title":"Syntax:","text":"<pre><code>wait (condition) begin\n    // Code to execute after the condition is true\nend\n</code></pre>"},{"location":"DSD/dsd_old/#example_1","title":"Example:","text":"<pre><code>reg signal, result;\n\ninitial begin\n    result = 0;\n    signal = 0;\n    #10 signal = 1;  // Signal changes after 10 time units\n    wait (signal == 1) begin\n        result = 1;   // Result is updated after signal becomes high\n    end\nend\n</code></pre>"},{"location":"DSD/dsd_old/#applications_1","title":"Applications","text":""},{"location":"DSD/dsd_old/#4-bit-adder","title":"4-bit Adder","text":"<p>A 4-bit adder adds two 4-bit binary numbers together, producing a 4-bit sum output along with a carry-out bit that indicates an overflow if the sum exceeds the capacity of 4 bits.</p> <p></p>"},{"location":"DSD/dsd_old/#ripple-carry-adder-rca","title":"Ripple Carry Adder (RCA)","text":"<pre><code>module FullAdder (A, B, Ci, Co, S);\n\n    input A, B, Ci;    // Inputs: A, B, and Carry In (Ci)\n    output S, Co;      // Outputs: Sum (S) and Carry Out (Co)\n\n    assign S = A ^ B ^ Ci;      // Sum calculation\n    assign Co = (A &amp; B) | (B &amp; Ci) | (A &amp; Ci);  // Carry Out calculation\n\nendmodule\n\n\nmodule Adder4 (S, Co, A, B, Ci);\n\n    input [3:0] A, B;  // 4-bit inputs\n    input Ci;          // Carry input\n    output [3:0] S;    // 4-bit sum output\n    output Co;         // Carry out\n    wire [3:1] C;      // Internal carry signals\n\n    // Instantiate 4 Full Adders\n    FullAdder FA0 (A[0], B[0], Ci, C[1], S[0]);\n    FullAdder FA1 (A[1], B[1], C[1], C[2], S[1]);\n    FullAdder FA2 (A[2], B[2], C[2], C[3], S[2]);\n    FullAdder FA3 (A[3], B[3], C[3], Co, S[3]);\n\nendmodule\n</code></pre>"},{"location":"DSD/dsd_old/#look-ahead-adder-cla","title":"Look-Ahead Adder (CLA)","text":"<p>A 4-bit carry look-ahead adder (CLA) is a faster alternative to the ripple carry adder, as it calculates the carries in parallel rather than waiting for each carry to propagate through the stages sequentially. The carry look-ahead adder computes the carry signals using the generate (G) and propagate (P) functions.</p> <pre><code>module cla_4bit (\n    input [3:0] A, B,\n    input Cin,\n    output [3:0] Sum,\n    output Cout\n);\n    wire [3:0] G, P;  // Generate and propagate signals\n    wire C1, C2, C3;\n\n    // Generate and propagate signals\n    assign G = A &amp; B;  // Generate\n    assign P = A | B;  // Propagate\n\n    // Carry look-ahead logic\n    assign #5 C1 = G[0] | (P[0] &amp; Cin);\n    assign #5 C2 = G[1] | (P[1] &amp; G[0]) | (P[1] &amp; P[0] &amp; Cin);\n    assign #5 C3 = G[2] | (P[2] &amp; G[1]) | (P[2] &amp; P[1] &amp; G[0]) | (P[2] &amp; P[1] &amp; P[0] &amp; Cin);\n    assign #5 Cout = G[3] | (P[3] &amp; G[2]) | (P[3] &amp; P[2] &amp; G[1]) | (P[3] &amp; P[2] &amp; P[1] &amp; G[0]) | (P[3] &amp; P[2] &amp; P[1] &amp; P[0] &amp; Cin);\n\n    // Sum calculation\n    assign #5 Sum[0] = A[0] ^ B[0] ^ Cin;\n    assign #5 Sum[1] = A[1] ^ B[1] ^ C1;\n    assign #5 Sum[2] = A[2] ^ B[2] ^ C2;\n    assign #5 Sum[3] = A[3] ^ B[3] ^ C3;\n\nendmodule\n</code></pre>"},{"location":"DSD/dsd_old/#delay-comparison-carry-look-ahead-adder-cla-vs-ripple-carry-adder-rca","title":"Delay Comparison: Carry Look-Ahead Adder (CLA) vs. Ripple Carry Adder (RCA)","text":""},{"location":"DSD/dsd_old/#1-ripple-carry-adder-rca","title":"1. Ripple Carry Adder (RCA)","text":"<ul> <li>Delay Growth: Linear <code>O(N)</code> (increases with the number of bits)</li> <li>Total Delay: <code>N * Gate Delay per Full Adder</code></li> </ul>"},{"location":"DSD/dsd_old/#2-carry-look-ahead-adder-cla","title":"2. Carry Look-Ahead Adder (CLA)","text":"<ul> <li>Delay Growth: Logarithmic <code>O(log N)</code> (grows slower as the number of bits increases)</li> <li>Total Delay: <code>log_2(N) * Gate Delay per Stage</code></li> </ul>"},{"location":"DSD/dsd_old/#3-comparison-of-delays","title":"3. Comparison of Delays","text":"Number of Bits RCA Delay (Linear) CLA Delay (Logarithmic) 4 bits 20 ns 20 ns 8 bits 40 ns 15 ns 16 bits 80 ns 20 ns 32 bits 160 ns 25 ns 64 bits 320 ns 30 ns"},{"location":"DSD/dsd_old/#4-to-1-mux","title":"4-to-1 Mux","text":"<p>A 4-to-1 multiplexer selects one of four input signals based on a 2-bit selection input and forwards the selected input to the output.</p> <p></p> <pre><code>module Mux4to1 (\n    input wire I0, I1, I2, I3,  // 4 data inputs\n    input wire S0, S1,          // 2 select lines\n    output wire Y               // Output\n);\n\nassign Y = (~S1 &amp; ~S0 &amp; I0) |  // Select I0 when S1 = 0, S0 = 0\n           (~S1 &amp;  S0 &amp; I1) |  // Select I1 when S1 = 0, S0 = 1\n           ( S1 &amp; ~S0 &amp; I2) |  // Select I2 when S1 = 1, S0 = 0\n           ( S1 &amp;  S0 &amp; I3);   // Select I3 when S1 = 1, S0 = 1\n\nendmodule\n</code></pre>"},{"location":"DSD/dsd_old/#shift-register","title":"Shift Register","text":""},{"location":"DSD/dsd_old/#4-bit-left-shift","title":"4-bit Left Shift","text":"<p>A 4-bit left shift register shifts the contents of the register one bit to the left on each clock cycle, with a new bit introduced at the least significant bit (LSB) and the most significant bit (MSB) being discarded.</p> <p></p> <pre><code>module LeftShiftRegister (\n    input wire clk,           // Clock input\n    input wire reset,         // Reset input\n    input wire D_in,          // Serial data input\n    output reg [3:0] Q        // 4-bit parallel output\n);\n\n// On the positive edge of the clock, perform the left shift\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        Q &lt;= 4'b0000;         // Reset all outputs to 0\n    end else begin\n        Q &lt;= {Q[2:0], D_in};  // Shift left and input new data bit on Q0\n    end\nend\n\nendmodule\n</code></pre>"},{"location":"DSD/dsd_old/#8-bit-left-shift","title":"8-bit Left Shift","text":"<pre><code>module shift_register_8bit (\n    input wire SI,     // Serial input\n    input wire Clk,    // Clock signal (rising edge)\n    input wire EN,     // Enable (active high)\n    output reg SO      // Serial output\n);\n\n    // Internal 8-bit register to hold the shift data\n    reg [7:0] shift_reg;\n\n    // Always block triggered on rising edge of clock\n    always @(posedge Clk) begin\n        if (EN) begin\n            // Shift register: shift in SI and shift out MSB (SO)\n            SO &lt;= shift_reg[7];      // MSB is shifted out\n            shift_reg &lt;= {shift_reg[6:0], SI};  // Shift left and input SI\n        end\n    end\n\nendmodule\n</code></pre>"},{"location":"DSD/dsd_old/#8-bit-counter-lab-3","title":"8-bit Counter (Lab 3)","text":"<p>Lab simulation: 3-Bit Up/Down counter with a clear and load.</p> <p>This lab involves designing an 8-bit up/down counter using Verilog, implemented on the NEXYS-4 FPGA board. A Vivado project is provided for this example.</p> <p>The CD74HC190/191 and CD54HC190/191 are highly versatile presettable up/down counters commonly used in digital electronics for tasks requiring accurate counting, such as digital clocks, timers, and frequency dividers. These ICs can be configured to count in either binary (CD74HC191) or BCD (Binary-Coded Decimal) format (CD74HC190), and support synchronous counting with a variety of control options, including asynchronous presetting, counting direction control, and enabling inputs. With additional outputs like ripple carry and terminal count, these counters are ideal for cascading multiple units to create larger counting systems.</p> <p>In Lab 3, we implemented an 8-bit up/down counter based on the functionality of the 74HC190/191 but directly in Verilog, bypassing the need for discrete hardware. This allowed us to overcome common design challenges such as signal ripple effects and cascading hazards that typically occur when connecting multiple 4-bit counters. By using Verilog, we streamlined the design, implementing advanced features such as parallel loading, which enables the counter to start from a user-defined value, and a clock control to slow down the counting process for easier observation.</p>"},{"location":"DSD/dsd_old/#identifying-required-number-of-bits","title":"Identifying Required Number of bits","text":"<p>To determine how many bits are needed to count to a specific number \\(N\\), use the following steps:</p> <ol> <li>Use the formula: <code>n = log2(N)</code> where <code>n</code> is the number of bits.</li> <li>Round up the result to the nearest whole number.</li> <li>A counter with <code>n</code> bits can represent numbers from <code>0</code> to <code>2^n - 1</code>, which must be greater than or equal to \\(N\\).</li> </ol>"},{"location":"DSD/dsd_old/#example_2","title":"Example:","text":"<p>To count up to 100:</p> <ol> <li><code>n = log2(100)</code> \u2248 6.64</li> <li>Round up to 7.</li> </ol> <p>You would need 7 bits to count up to 100, as 7 bits can represent values from 0 to 127.</p>"},{"location":"DSD/dsd_old/#parallel-loading","title":"Parallel Loading","text":"<p>Parallel loading allows a counter to load a preset value into all its flip-flops simultaneously in a single clock cycle. By using input lines (like A-D or D0-D3) and a load signal, the counter can instantly update its value upon the next clock cycle, bypassing the need for sequential counting. This is particularly useful for initializing the counter or synchronizing multiple counters efficiently. In this lab, we used parallel loading to preset the 8-bit counter with values determined by the input switches, adding greater flexibility to the counting process.</p>"},{"location":"DSD/dsd_old/#synchronous-4-bit-updown-counter-74hc192","title":"Synchronous 4-bit Up/Down Counter (74HC192)","text":"<pre><code>module counter_74HC192 (\n    input wire Clr,      // Clear the counter\n    input wire Load,     // Load the counter with a value\n    input wire Up,       // Count up when asserted\n    input wire Down,     // Count down when asserted\n    input wire [3:0] P,  // Data input for loading preset\n    input wire Clk,      // Clock input\n    output reg [3:0] Q   // 4-bit counter output\n);\n\n// Always block, sensitive to Clk, Clr, Load, Up, Down\nalways @(posedge Clk or posedge Clr or posedge Load) begin\n    if (Clr) begin\n        Q &lt;= 4'b0000;  // Clear the counter\n    end\n    else if (Load) begin\n        Q &lt;= D;  // Load the counter with input value\n    end\n    else if (Up &amp;&amp; !Down) begin\n        Q &lt;= Q + 1;  // Increment counter\n    end\n    else if (Down &amp;&amp; !Up) begin\n        Q &lt;= Q - 1;  // Decrement counter\n    end\nend\n\nendmodule\n</code></pre>"},{"location":"DSD/dsd_old/#sr-latch","title":"SR Latch","text":""},{"location":"DSD/dsd_old/#sr-latch-using-a-boolean-equation","title":"SR Latch Using a Boolean Equation","text":"<pre><code>module sr_latch_boolean (\n    input wire S,   // Set input\n    input wire R,   // Reset input\n    output reg Q,   // Output\n    output reg Qn   // Inverted output\n);\n\n    always @(*) begin\n        if (S &amp;&amp; !R) begin\n            Q &lt;= 1;   // Set\n            Qn &lt;= 0;\n        end\n        else if (!S &amp;&amp; R) begin\n            Q &lt;= 0;   // Reset\n            Qn &lt;= 1;\n        end\n        // If S == 0 and R == 0, Q and Qn retain previous state (no action)\n    end\n\nendmodule\n</code></pre>"},{"location":"DSD/dsd_old/#sr-latch-using-gate-level-description","title":"SR Latch Using Gate-Level Description","text":"<pre><code>module sr_latch_gate_level (\n    input wire S,   // Set input\n    input wire R,   // Reset input\n    output wire Q,  // Output\n    output wire Qn  // Inverted output\n);\n\n    wire nand1_out, nand2_out;\n\n    // NAND gates for SR Latch\n    nand (nand1_out, S, Qn);  // First NAND gate\n    nand (nand2_out, R, Q);   // Second NAND gate\n\n    assign Q = nand1_out;\n    assign Qn = nand2_out;\n\nendmodule\n</code></pre>"},{"location":"DSD/dsd_old/#4-bit-comparator","title":"4-bit Comparator","text":"<p>A 4-bit comparator is a digital circuit that compares two 4-bit binary numbers and outputs the result of their comparison. It determines whether one number is greater than, less than, or equal to the other.</p>"},{"location":"DSD/dsd_old/#inputs","title":"Inputs","text":"<ul> <li>A[3:0]: 4-bit binary number (A3, A2, A1, A0)</li> <li>B[3:0]: 4-bit binary number (B3, B2, B1, B0)</li> </ul>"},{"location":"DSD/dsd_old/#outputs","title":"Outputs","text":"<ul> <li>A &gt; B: Output is 1 if the binary number A is greater than B.</li> <li>A &lt; B: Output is 1 if the binary number A is less than B.</li> <li>A = B: Output is 1 if the binary number A is equal to B.</li> </ul>"},{"location":"DSD/dsd_old/#logic-for-comparison","title":"Logic for Comparison","text":"<p>To compare two 4-bit numbers, the comparison starts from the most significant bit (MSB) down to the least significant bit (LSB):</p> <ol> <li>A &gt; B:</li> <li>If A3 &gt; B3, then A &gt; B regardless of the lower bits.</li> <li>If A3 = B3, move to compare A2 and B2.</li> <li> <p>Repeat for all bits until a difference is found or A = B.</p> </li> <li> <p>A &lt; B:</p> </li> <li>If A3 &lt; B3, then A &lt; B.</li> <li>If A3 = B3, move to compare A2 and B2.</li> <li> <p>Continue this until a difference is found or A = B.</p> </li> <li> <p>A = B:</p> </li> <li>If all bits (A3 to A0) are equal to their corresponding B bits, then A = B.</li> </ol>"},{"location":"DSD/dsd_old/#truth-table","title":"Truth Table","text":"A3 A2 A1 A0 B3 B2 B1 B0 A &gt; B A &lt; B A = B 0 0 0 1 0 0 0 1 0 0 1 1 0 1 0 0 1 1 0 1 0 0 0 1 1 1 1 0 0 1 0 1 0 ... ... ... ... ... ... ... ... ... ... ..."},{"location":"DSD/dsd_old/#verilog-implementation","title":"Verilog Implementation","text":"<p>A simple implementation in Verilog:</p> <pre><code>module Comparator4bit(\n    input [3:0] A, B,\n    output A_greater, A_less, A_equal\n);\n\nassign A_greater = (A &gt; B);\nassign A_less = (A &lt; B);\nassign A_equal = (A == B);\n\nendmodule\n</code></pre>"},{"location":"DSD/dsd_old/#nexys-a7","title":"Nexys A7","text":"<p>Nexys A7 Reference Manual</p> <p></p>"},{"location":"DSD/dsd_old/#to-do","title":"To do","text":"<ol> <li>Bypass capacitors required in FPGAs</li> <li>Division, except by powers of 2 is not supported in Vivado</li> <li>If you use an if statement, but don\u2019t have an else, the synthesizer may create a latch you did not expect.</li> <li>Synthesis vs implementation</li> </ol>"},{"location":"DSD/logicDesign/","title":"Logic Design","text":""},{"location":"DSD/logicDesign/#boolean-algebra","title":"Boolean Algebra","text":"Rule Expression Hint Identity Law A + 0 = A No change when OR'ed with 0 Identity Law A \u2022 1 = A No change when AND'ed with 1 Null Law A + 1 = 1 OR'ing with 1 results in 1 Null Law A \u2022 0 = 0 AND'ing with 0 results in 0 Complement Law A + A' = 1 A variable OR'ed with its complement is 1 Complement Law A \u2022 A' = 0 A variable AND'ed with its complement is 0 Idempotent Law A + A = A OR'ing a variable with itself leaves it unchanged Idempotent Law A \u2022 A = A AND'ing a variable with itself leaves it unchanged Domination Law A + A'B = A + B Apply the Distributive Law to simplify Distributive Law A(B + C) = AB + AC Distributes AND over OR Distributive Law A + BC = (A + B)(A + C) Distributes OR over AND Absorption Law A + AB = A Removes redundant terms Absorption Law A(A + B) = A Removes redundant terms Double Negation Law (A')' = A Negation of a negation returns the original value De Morgan\u2019s Law (A \u2022 B)' = A' + B' Apply to break AND terms when converting SOP to POS De Morgan\u2019s Law (A + B)' = A' \u2022 B' Apply to break OR terms when converting POS to SOP Involution Law (A'') = A A variable twice negated is equal to itself Consensus Theorem AB + A'C + BC = AB + A'C Simplifies expressions by eliminating redundant terms Distributive (SOP to POS hint) A + BC = (A + B)(A + C) Useful for converting SOP to POS Distributive (POS to SOP hint) A(B + C) = AB + AC Useful for converting POS to SOP Demorgans (SOP to POS hint) (A \u2022 B)' = A' + B' Apply De Morgan\u2019s Law during the conversion Demorgans (POS to SOP hint) (A + B)' = A' \u2022 B' Apply De Morgan\u2019s Law during the conversion Redundancy Law AB + AB' = A Removes redundant variables from the equation"},{"location":"DSD/logicDesign/#sequential-and-combinational-assignments","title":"Sequential and Combinational Assignments","text":"<ul> <li>Sequential = Procedural: Sequential logic updates state based on clock edges and uses procedural assignments, typically with non-blocking (<code>&lt;=</code>) assignments. It is modeled inside <code>always</code> blocks that are sensitive to clock edges (e.g., <code>posedge clk</code>). This describes systems like flip-flops or registers that rely on previous states.</li> </ul> <p>Example: <code>verilog   always @(posedge clk or posedge reset) begin       if (reset)           q &lt;= 0;      // Asynchronous reset       else           q &lt;= d;      // Update q with d at clock edge   end</code></p> <ul> <li> <p>Combinational = Continuous: Combinational logic depends purely on the current inputs and is described using continuous (blocking) assignments. It models circuits like AND, OR gates, where output is updated as soon as inputs change, without regard to clock cycles.</p> <p>Example: <code>verilog assign y = a &amp; b;  // Output y changes immediately based on a and b</code></p> </li> </ul>"},{"location":"DSD/logicDesign/#relevant-constructs","title":"Relevant Constructs","text":"<ul> <li> <p><code>always</code> blocks: Used to describe both sequential and combinational logic. For sequential logic, <code>always @(posedge clk)</code> or <code>always @(negedge clk)</code> is used, whereas for combinational logic, <code>always @(*)</code> is used to capture all input changes automatically.     Example: <code>verilog     always @(*) begin         result = a | b;  // Combinational logic triggered by any input change     end</code></p> </li> <li> <p><code>initial</code> blocks: Used to define initial conditions in simulations. They execute once at the start of the simulation and are commonly used for testbenches or initializing registers/variables in simulation but are not synthesized into hardware.     Example <code>verilog     initial begin         reg_x = 0;  // Initialize reg_x to 0 at simulation start     end</code></p> </li> </ul>"},{"location":"DSD/logicDesign/#key-points","title":"Key Points","text":"<ul> <li>Blocking (<code>=</code>) vs. Non-blocking (<code>&lt;=</code>): In sequential logic (<code>always @(posedge clk)</code>), use non-blocking assignments (<code>&lt;=</code>) to ensure parallel updates. In combinational logic, blocking assignments (<code>=</code>) can be used to execute statements sequentially.</li> </ul>"},{"location":"DSD/logicDesign/#state-machine","title":"State Machine","text":"<p>A state machine is a computational model used to design both software and hardware systems. It consists of a set of states, transitions between states, and actions that occur based on inputs.</p>"},{"location":"DSD/logicDesign/#components","title":"Components","text":"<ol> <li>States: Defined conditions or situations the system can be in.</li> <li>Transitions: Conditions that trigger a change from one state to another.</li> <li>Inputs: External events or conditions that affect state transitions.</li> <li>Outputs: Actions or results produced during or after a state transition.</li> </ol>"},{"location":"DSD/logicDesign/#types-of-state-machines","title":"Types of State Machines","text":"<ol> <li>Finite State Machine (FSM): Has a finite number of states and transitions between them.</li> <li>Deterministic FSM (DFA): Every state has exactly one transition for each input.</li> <li> <p>Non-deterministic FSM (NFA): A state can have multiple transitions for the same input.</p> </li> <li> <p>Mealy Machine: The output depends on both the current state and the input.</p> </li> <li>Moore Machine: The output depends only on the current state.</li> </ol>"},{"location":"DSD/logicDesign/#applications","title":"Applications","text":"<ul> <li>Control Systems: Used in embedded systems for managing device behavior.</li> <li>Protocols: Helps in defining the sequence of operations in communication protocols.</li> <li>Game Design: To model different game states such as playing, paused, or game over.</li> </ul>"},{"location":"DSD/logicDesign/#example","title":"Example","text":"<pre><code>module fsm_example (\n    input wire clk,        // Clock input\n    input wire reset,      // Asynchronous reset signal (active high)\n    input wire trigger,    // Trigger input to transition between states\n    output reg out         // Output signal that depends on the current state\n);\n\n    // Define the states as an enumerated type using a 2-bit register\n    typedef enum reg [1:0] {\n        IDLE   = 2'b00,    // State 0: Idle state (default)\n        STATE1 = 2'b01,    // State 1: Represents the first active state\n        STATE2 = 2'b10     // State 2: Represents the second active state\n    } state_t;\n\n    // Current state and next state registers\n    reg state_t current_state, next_state;\n\n    // Sequential logic for state transition\n    // This block updates the current state on every clock edge or reset\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state &lt;= IDLE;   // On reset, go to IDLE state\n        end else begin\n            current_state &lt;= next_state;  // On clock, update to the next state\n        end\n    end\n\n    // Combinational logic for state transition based on current state and input trigger\n    always @(*) begin\n        // Default next state and output values\n        next_state = current_state; // Hold the current state by default\n        out = 1'b0;                 // Default output is 0\n\n        // State transition logic\n        case (current_state)\n            IDLE: begin\n                // In IDLE, if 'trigger' is high, move to STATE1\n                if (trigger)\n                    next_state = STATE1;\n                // Output remains 0 in IDLE\n            end\n\n            STATE1: begin\n                // In STATE1, set output high\n                out = 1'b1;\n                // If 'trigger' is high, move to STATE2, otherwise go back to IDLE\n                if (trigger)\n                    next_state = STATE2;\n                else\n                    next_state = IDLE;\n            end\n\n            STATE2: begin\n                // In STATE2, output remains high\n                out = 1'b1;\n                // If 'trigger' goes low, return to IDLE\n                if (!trigger)\n                    next_state = IDLE;\n            end\n\n            default: begin\n                // Default case to handle any undefined state (shouldn't happen)\n                next_state = IDLE; // Return to IDLE state if something goes wrong\n            end\n        endcase\n    end\n\nendmodule\n</code></pre>"},{"location":"DSD/simulations/","title":"Simulations","text":""},{"location":"DSD/simulations/#delays-in-verilog","title":"Delays in Verilog","text":"<p>Propagation delays in Verilog simulate the time it takes for signals to propagate through circuits.</p>"},{"location":"DSD/simulations/#delayed-assignments","title":"Delayed Assignments","text":"<p>In continuous assignments, use <code>#delay</code> to specify how long it takes for the output to update after a change in the inputs.</p> <pre><code> assign #5 y = a &amp; b;  // y updates 5 time units after a or b changes \n ```\n\n### Why Use Delays?\n\n- **Timing Simulation:** Models real-world signal delays.\n- **Accurate Behavior:** Ensures proper timing in combinational logic.\n\n### Delays in Procedural Assignments\n\nDelays can also be applied in **procedural blocks** like `always`:\n\n```verilog\n always @ (a or b) begin\n    #3 out = a &amp; b;  // out updates 3 time units after input changes\nend \n</code></pre>"},{"location":"DSD/simulations/#inertial-vs-transport-delays","title":"Inertial vs. Transport Delays","text":"<ul> <li>Inertial Delay: This is the default type of delay in Verilog. It filters out glitches, meaning only input pulses longer than the delay propagate to the output. </li> <li>Example: If <code>#5</code> is used, pulses shorter than 5 time units will be filtered.</li> </ul> <p><code>verilog   assign #5 y = a &amp; b;  // Inertial delay, y updates only if changes persist for 5 time units</code></p> <ul> <li>Transport Delay: This models a physical delay without filtering any input pulses. Even if an input changes rapidly, the signal is propagated to the output after the delay.</li> <li>Example: Use <code>transport</code> to force transport delay behavior.</li> </ul> <p><code>verilog   assign #5 y = transport a &amp; b;  // Transport delay, y updates exactly 5 time units after input change</code></p>"},{"location":"DSD/simulations/#key-differences","title":"Key Differences:","text":"<ul> <li>Inertial delay: Mimics real-world circuits where short glitches are filtered.</li> <li>Transport delay: Models pure signal propagation without glitch filtering.</li> </ul>"},{"location":"DSD/simulations/#wait-statements","title":"Wait Statements","text":"<p>In Verilog, the <code>wait</code> statement is used to pause the execution of a block until a certain condition becomes true. Unlike an <code>always</code> or <code>@(posedge clk)</code> block that waits for specific events (like clock edges), the <code>wait</code> statement halts the execution until the specified condition is met. Primarily used with delays to simulate hardware restrictions.</p>"},{"location":"DSD/simulations/#syntax","title":"Syntax:","text":"<pre><code>wait (condition) begin\n    // Code to execute after the condition is true\nend\n</code></pre>"},{"location":"DSD/simulations/#example","title":"Example:","text":"<pre><code>reg signal, result;\n\ninitial begin\n    result = 0;\n    signal = 0;\n    #10 signal = 1;  // Signal changes after 10 time units\n    wait (signal == 1) begin\n        result = 1;   // Result is updated after signal becomes high\n    end\nend\n</code></pre>"},{"location":"DSD/verilog/","title":"Verilog","text":""},{"location":"DSD/verilog/#data-types","title":"Data Types","text":"Data Type Purpose Characteristics <code>wire</code> Combinational logic and connections Cannot hold state, used in continuous assignments <code>reg</code> Sequential and combinational logic Holds state, used inside <code>always</code> blocks <code>integer</code> Signed 32-bit value for loops/counters Used in loops and non-synthesizable code <code>real</code> Floating-point value Used in non-synthesizable, behavioral code <code>time</code> 64-bit value to represent simulation time Used for timing and measuring delays in simulation <code>tri</code> Tri-state buffer signal Can take high-impedance (<code>Z</code>) values"},{"location":"DSD/verilog/#vectors-in-verilog","title":"Vectors in Verilog","text":"<p>Vectors in Verilog are used to represent multi-bit signals, which are crucial when dealing with buses, registers, or large numbers. They allow for grouping multiple bits into a single variable.</p> <p>A vector is declared by specifying the range of bits using <code>[MSB:LSB]</code>, where MSB is the most significant bit and LSB is the least significant bit.</p> <pre><code>wire [3:0] bus;   // 4-bit wide wire (vector)\nreg  [7:0] data;  // 8-bit register\n</code></pre> <p>Individual bits or a range of bits within a vector can be accessed as follows:</p> <pre><code>wire [7:0] data;\nassign bit3 = data[3];     // Accessing the 3rd bit of data\nassign lower_nibble = data[3:0];  // Accessing the lower 4 bits of data\n</code></pre> <p>You can assign values directly to vectors:</p> <pre><code>reg [3:0] result;\nresult = 4'b1010;  // Assigning binary value\nresult = 4'hA;     // Assigning hexadecimal value\n</code></pre> <p>A vector can have zero width when the MSB and LSB are the same, meaning it's a single-bit signal:</p> <pre><code>wire [0:0] single_bit;  // Equivalent to a scalar\n</code></pre> <p>By default, vectors are unsigned, but they can be declared as signed if needed:</p> <pre><code>signed reg [7:0] signed_data;  // Signed 8-bit register\n</code></pre> <p>In signed vectors, the most significant bit (MSB) is treated as the sign bit.</p>"},{"location":"DSD/verilog/#primitives","title":"Primitives","text":"<p>A Verilog primitive is a pre-defined logic element used in digital designs. These include basic gates like <code>and</code>, <code>or</code>, <code>nand</code>, and <code>xor</code>, with fixed functions that don't require module definitions.</p> <p>Output Declaration: In Verilog, when declaring a UDP, the output must always be listed first, followed by the input(s). This order is essential for the proper functioning of the UDP.</p> <p>Types of Primitives: - Combinational Primitives: e.g., <code>and</code>, <code>or</code>, <code>xor</code> - Sequential Primitives: Flip-flops, latches</p>"},{"location":"DSD/verilog/#user-defined-primitives-udps","title":"User Defined Primitives (UDPs)","text":"<p>UDPs are custom-defined logic, either combinational or sequential, declared using the <code>primitive</code> keyword. They use a truth table to define behavior.</p> <ul> <li>Example (Combinational UDP):     ```verilog<pre><code>primitive my_and (out, in1, in2);  \noutput out;  \ninput in1, in2;\n\n// The 'table' defines the behavior of this custom primitive.\n// Each row in the table specifies input combinations and the corresponding output.\n// For an AND gate, the output is 1 only when both inputs are 1.\ntable\n    0 0 : 0;  // If both inputs are 0, the output is 0.\n    1 1 : 1;  // If both inputs are 1, the output is 1.\n    // For simplicity, intermediate input states (like 0 1 or 1 0) are not explicitly defined here,\n    // but in a full AND gate implementation, these would typically output 0.\nendtable\n\nendprimitive\n</code></pre> <p>```</p> </li> </ul>"},{"location":"DSD/verilog/#verilog-operator-precedence","title":"Verilog Operator Precedence","text":"<p>In Verilog, operators follow a specific order of precedence. This determines how expressions are evaluated when there are multiple operators in the same expression. Below is the list of operators in order of precedence, from highest to lowest:</p> <ol> <li>Unary operators</li> <li><code>+</code>, <code>-</code> (unary plus and minus)</li> <li><code>!</code> (logical NOT)</li> <li><code>~</code> (bitwise NOT)</li> <li><code>&amp;</code>, <code>~&amp;</code> (reduction AND, NAND)</li> <li><code>|</code>, <code>~|</code> (reduction OR, NOR)</li> <li> <p><code>^</code>, <code>~^</code>, <code>^~</code> (reduction XOR, XNOR)</p> </li> <li> <p>Multiplicative operators</p> </li> <li> <p><code>*</code>, <code>/</code>, <code>%</code> (multiply, divide, modulus)</p> </li> <li> <p>Additive operators</p> </li> <li> <p><code>+</code>, <code>-</code> (addition, subtraction)</p> </li> <li> <p>Shift operators</p> </li> <li> <p><code>&lt;&lt;</code>, <code>&gt;&gt;</code> (logical shift left, right)</p> </li> <li> <p>Relational operators</p> </li> <li> <p><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> (less than, less than or equal, greater than, greater than or equal)</p> </li> <li> <p>Equality operators</p> </li> <li><code>==</code>, <code>!=</code> (logical equality, inequality)</li> <li> <p><code>===</code>, <code>!==</code> (case equality, case inequality)</p> </li> <li> <p>Bitwise operators</p> </li> <li> <p><code>&amp;</code>, <code>|</code>, <code>^</code>, <code>^~</code>, <code>~^</code> (AND, OR, XOR, XNOR)</p> </li> <li> <p>Logical operators</p> </li> <li><code>&amp;&amp;</code> (logical AND)</li> <li> <p><code>||</code> (logical OR)</p> </li> <li> <p>Conditional operator</p> </li> <li> <p><code>? :</code> (ternary operator)</p> </li> <li> <p>Assignment operators</p> <ul> <li><code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&amp;=</code>, <code>|=</code>, <code>^=</code> (assignment and compound assignments)</li> </ul> </li> </ol>"},{"location":"DSD/verilog/#shifts","title":"Shifts","text":"<p>In Verilog, shift operations move bits of a value to the left or right. There are two types: logical shifts and arithmetic shifts.</p>"},{"location":"DSD/verilog/#1-logical-shifts","title":"1. Logical Shifts","text":"<p>Logical shifts move bits and fill the vacated positions with zeros.</p> <p>a. Logical Left Shift (<code>&lt;&lt;</code>) Shifts bits to the left by the specified amount, inserting zeros on the right. This is equivalent to multiplying by a power of 2.</p> <p>Syntax:</p> <pre><code>result = value &lt;&lt; shift_amount;\n</code></pre> <p>Example:</p> <pre><code>wire [3:0] value = 4'b1010; \nassign result = value &lt;&lt; 1;  // Result: 0100\n</code></pre> <p>b. Logical Right Shift (<code>&gt;&gt;</code>) Shifts bits to the right, inserting zeros on the left.</p> <p>Syntax:</p> <pre><code>result = value &gt;&gt; shift_amount;\n</code></pre> <p>Example:</p> <pre><code>wire [3:0] value = 4'b1010;\nassign result = value &gt;&gt; 1;  // Result: 0101\n</code></pre>"},{"location":"DSD/verilog/#2-arithmetic-shifts","title":"2. Arithmetic Shifts","text":"<p>Arithmetic shifts preserve the sign of signed numbers when shifting right.</p> <p>a. Arithmetic Right Shift (<code>&gt;&gt;&gt;</code>) Shifts bits to the right, preserving the sign by filling the leftmost bits with the sign bit (MSB).</p> <p>Syntax:</p> <pre><code>result = value &gt;&gt;&gt; shift_amount;\n</code></pre> <p>Example:</p> <pre><code>wire signed [3:0] value = -4;  // Binary: 1100 (two's complement)\nassign result = value &gt;&gt;&gt; 1;   // Result: 1110\n</code></pre>"},{"location":"DSD/verilog/#functions-and-tasks","title":"Functions and Tasks","text":"Aspect Functions Tasks Return Type Returns a single value. Can return multiple values via <code>output</code> ports. Time Control No timing control (<code>#</code>, <code>@</code>, <code>wait</code> not allowed). Supports timing control (can use <code>#</code>, <code>@</code>, <code>wait</code>). Arguments Only <code>input</code> arguments. Can have <code>input</code>, <code>output</code>, and <code>inout</code> arguments. Usage Used in expressions directly. Called as a separate statement. Execution Time Executes in zero simulation time. Takes simulation time to execute. Use Case Simple, combinational calculations. Complex tasks with delays or multiple outputs."},{"location":"DSD/verilog/#example-function","title":"Example Function:","text":"<pre><code>function [3:0] add;\n  input [3:0] a, b;\n  begin\n    add = a + b;\n  end\nendfunction\n</code></pre>"},{"location":"DSD/verilog/#example-task","title":"Example Task:","text":"<pre><code>task add_sub;\n  input [3:0] a, b;\n  output [3:0] sum, diff;\n  begin\n    sum = a + b;\n    diff = a - b;\n  end\nendtask\n</code></pre>"},{"location":"DSD/verilog/#example-task-with-event-control","title":"Example Task (With Event Control):","text":"<pre><code>task event_control_example;\n  input [3:0] a, b;\n  output reg [3:0] result;\n  begin\n    wait (a == b);   // Wait until a equals b\n    result = a + b;  // Perform addition\n  end\nendtask\n</code></pre>"},{"location":"DSD/verilog/#example-task-with-output-and-inout-arguments-called-as-a-separate-statement","title":"Example Task (with <code>output</code> and <code>inout</code> Arguments Called as a Separate Statement):","text":"<pre><code>module task_example;\n  reg [3:0] x, y, z, sum_result, diff_result;\n\n  initial begin\n    x = 4'b1010;              // Assign some values\n    y = 4'b0110;\n    z = 4'b0011;\n\n    // Call the task as a separate statement\n    arithmetic_operations(x, y, sum_result, z);  // `z` will be modified in-place as an inout\n  end\nendmodule\n\ntask arithmetic_operations;\n  input [3:0] a, b;           // Input arguments\n  output reg [3:0] sum;       // Output argument\n  inout [3:0] diff;           // Inout argument\n  begin\n    sum = a + b;              // Perform addition\n    diff = diff - a;          // Modify the inout value\n  end\nendtask\n</code></pre>"},{"location":"Physics/pages/","title":"Overview","text":""},{"location":"Physics/pages/#quanta-and-fields","title":"Quanta and Fields","text":"<p>This is a collection of notes I've taken while reading Quanta and Fields by Sean Carroll, much of the details are expanded on using other resources but the general framework was derived from Sean Carroll.</p> <ol> <li>The Wave Function</li> <li>Measurement</li> <li>Entanglement</li> </ol>"},{"location":"Physics/pages/entanglement/","title":"Entanglement","text":"<p>From Sean Carroll's \"Quantum and Fields\"</p>"},{"location":"Physics/pages/entanglement/#key-concepts","title":"Key Concepts","text":""},{"location":"Physics/pages/entanglement/#1-particle-decay-and-momentum","title":"1. Particle Decay and Momentum","text":"<p>In quantum mechanics, particle decay is described by the wavefunction:</p> \\[|\\psi(t)\\rangle = \\alpha(t) |\\text{undecayed}\\rangle + \\beta(t) |\\text{decayed}\\rangle\\] <p>Here, \\(\\alpha(t)\\) represents the amplitude for the particle to remain undecayed, and \\(\\beta(t)\\) represents the amplitude for the particle to decay. The normalization condition ensures: $$ |\\alpha(t)|^2 + |\\beta(t)|^2 = 1 $$</p> <p>Over time, the probability of the particle remaining undecayed decreases, and the probability of decay increases. The survival probability at time \\(t\\) is \\(P_{\\text{undecayed}}(t) = |\\alpha(t)|^2\\), and the probability of the particle decaying is \\(P_{\\text{decayed}}(t) = 1 - |\\alpha(t)|^2\\).</p> <p>Momentum conservation plays a crucial role in particle decay. The total momentum before and after decay remains the same: $$ \\vec{p}{\\text{original}} = \\vec{p}{1} + \\vec{p}{2} $$ where \\(\\vec{p}_{\\text{original}}\\) is the momentum of the original particle, and \\(\\vec{p}_{1}\\) and \\(\\vec{p}_{2}\\) are the momenta of the decay products. This allows us to calculate the momentum of one decay product without directly observing it: $$ \\vec{p}{2} = \\vec{p}{\\text{original}} - \\vec{p}{1} $$</p> <p>Example: Decaying Boson Consider a stationary boson that decays into an electron-positron pair. Since the original boson has no initial momentum (\\(\\vec{p}_{\\text{original}} = 0\\)), the momentum of the electron and positron must be equal and opposite to conserve momentum: $$ \\vec{p}{\\text{positron}} = -\\vec{p}{\\text{electron}} $$ If we know the position of the original boson before decay, we can measure the momentum of one of the decay products (e.g., the positron) and use momentum conservation to determine the momentum of the other particle, even without directly measuring it. This is useful in particle physics experiments, where some particles (like neutrinos) are hard to detect directly. By measuring other decay products, we can infer properties of the undetected particles.</p>"},{"location":"Physics/pages/entanglement/#2-entanglement-one-state-many-parts","title":"2. Entanglement: One State, Many Parts","text":"<p>Entanglement describes a quantum phenomenon where the states of two or more particles become deeply interconnected. Unlike classical systems, where particles are independent, entangled particles share a combined quantum state. This means that measuring one particle\u2019s state instantly determines the state of the other, no matter the distance between them.</p> <p>The entangled state is typically written as: $$ |\\psi\\rangle = \\frac{1}{\\sqrt{2}} \\left( |\\uparrow\\rangle_1 |\\downarrow\\rangle_2 - |\\downarrow\\rangle_1 |\\uparrow\\rangle_2 \\right) $$ Here, \\(|\\uparrow\\rangle_1\\) and \\(|\\downarrow\\rangle_2\\) represent the spin states of two entangled particles. Measuring the spin of one particle gives immediate knowledge of the spin of the other.</p> <p>Building on the previous example of particle decay, we see how momentum conservation connects the decay products. Similarly, entangled particles are not independent; they are connected in such a way that measuring one particle gives us information about the other, even if they are far apart.</p> <p>In quantum mechanics, entanglement goes beyond momentum conservation. It links the properties of particles in a non-local way, forming a single quantum system that cannot be separated into individual parts. This phenomenon is fundamental to quantum technologies like quantum cryptography and quantum teleportation, which exploit these correlations to achieve tasks impossible with classical systems.</p>"},{"location":"Physics/pages/entanglement/#3-spooky-action-at-a-distance-and-the-epr-puzzle","title":"3. Spooky Action at a Distance and the EPR Puzzle","text":"<p>The term \"spooky action at a distance\" was coined by Einstein to criticize the non-local nature of quantum entanglement. It describes how entangled particles exhibit correlations that seem to violate the principle of locality, which states that objects are only directly influenced by their immediate surroundings.</p> <p>Key Features</p> <ul> <li>Entangled particles, even when separated by vast distances, are correlated in such a way that measuring one particle\u2019s state (e.g., its spin or polarization) immediately determines the state of the other. This happens instantaneously, seemingly defying the constraints of space and time.</li> <li>Importantly, this \"spooky action\" does not allow faster-than-light communication, thus preserving causality in quantum mechanics. While the information is transmitted instantaneously, it cannot be used to send information faster than light, which prevents paradoxes.  <ul> <li>For example, if Bob and Alice have an entangled pair and travel great distances from each other, when Bob measures his particle, he will immediately know the state of Alice\u2019s particle. However, Alice, unaware of Bob's measurement, still has the same odds of measurement outcomes as if Bob never measured his particle. The act of measuring Bob's particle doesn't change the fact that Alice's measurement will still have a probabilistic outcome based on her own measurements. Making the instantaneous information useless for communication between observers.</li> </ul> </li> </ul> <p>The EPR Puzzle</p> <p>Proposed by Einstein, Podolsky, and Rosen (EPR) in 1935, the EPR thought experiment challenged the completeness of quantum mechanics. EPR argued that if quantum mechanics were complete, it would have to explain physical reality through either:</p> <ol> <li>Local Realism: Particles have pre-existing properties (hidden variables) that determine their behavior before measurement.</li> <li>Non-Locality: The measurement of one particle instantaneously affects the state of another, regardless of the distance between them.</li> </ol> <p>EPR believed that non-locality was problematic because it implies that quantum mechanics allows for instantaneous influences between distant particles, which violates classical ideas of locality and causality. This made quantum mechanics seem incomplete because it relied on non-local effects without offering a fully deterministic explanation.</p> <p>Quantum mechanics rejects local realism and embraces non-locality through entanglement, where the state of entangled particles is not determined until one is measured, and the measurement of one affects the state of the other instantly.</p> <p>The EPR paradox led to experiments testing Bell's Theorem, which showed that quantum mechanics\u2019 predictions cannot be reproduced by any theory based on local hidden variables, confirming that non-locality is an intrinsic feature of quantum mechanics.</p>"},{"location":"Physics/pages/entanglement/#4-decoherence-theory-the-quantum-classical-divide","title":"4. Decoherence Theory: The Quantum-Classical Divide","text":"<p>Decoherence Theory argues the wave function never truly collapses. Instead, the appearance of collapse happens because the quantum system becomes entangled with its environment, making certain quantum behaviors (like interference) inaccessible to us as observers.</p> <p>Key Concepts</p> <ul> <li> <p>Interaction with the Environment:   Decoherence occurs when a quantum system interacts with its environment, such as measurement devices, air molecules, or photons. These interactions cause the quantum system to become entangled with the environment, making the superpositions of quantum states effectively unobservable.</p> </li> <li> <p>Entanglement with the Measurement Apparatus:   In quantum mechanics, when a measurement is made, the quantum system becomes entangled with the measuring device. This means that the state of the system and the state of the apparatus are linked. The act of measurement doesn't just collapse the system's state but causes both the system and the apparatus to evolve into a combined state.</p> </li> <li> <p>Why Big Things Appear Classical:   Macroscopic systems interact with their environment on a massive scale, causing rapid and irreversible decoherence. The entanglement between the system and its surroundings destroys quantum coherence, making superpositions unobservable and the system behave as though it has a single classical state.</p> </li> <li> <p>Loss of Superposition:   As the quantum system entangles with the environment or measuring device, its superposition states (e.g., being in two places at once) effectively disappear. The system appears to collapse into one definite classical state as the environment \"measures\" it.</p> </li> <li> <p>No Wavefunction Collapse:   Decoherence does not imply a traditional wavefunction collapse. Instead, it explains why certain outcomes appear classical: the system is entangled with the environment in such a way that it no longer displays quantum superposition in a measurable way.</p> </li> </ul> <p>Implications</p> <ul> <li> <p>Quantum to Classical Transition:   Decoherence helps explain why macroscopic systems behave classically. When a quantum system interacts with a large environment, it loses its quantum coherence and behaves as a classical system, even though the underlying dynamics remain quantum.</p> </li> <li> <p>Measurement Problem:   Decoherence helps solve the measurement problem by showing how measurement interactions between the system and the apparatus lead to classical outcomes. The entanglement between the system and measurement apparatus prevents the superposition from being observed in practice.</p> </li> <li> <p>Quantum Computing:   In quantum computing, decoherence is a significant challenge. Qubits are highly susceptible to decoherence from environmental interactions, which limits the time during which quantum information can be preserved. Reducing decoherence is critical for reliable quantum computing.</p> </li> </ul>"},{"location":"Physics/pages/entanglement/#5-foundations-of-quantum-mechanics","title":"5. Foundations of Quantum Mechanics","text":"<p>The foundations of quantum mechanics explore principles, interpretations, and unresolved questions at the core of the theory. Below are common theories:</p> <ol> <li> <p>Copenhagen Interpretation    Quantum systems are described by a wavefunction that collapses upon measurement. Measurement defines reality, but the collapse mechanism remains unexplained.</p> </li> <li> <p>Many-Worlds Interpretation    All possible outcomes occur in separate, branching universes. There is no wavefunction collapse, and the universe evolves deterministically.</p> </li> <li> <p>Pilot-Wave Theory (Bohmian Mechanics)    Particles follow definite trajectories guided by a \"pilot wave.\" This restores determinism but introduces non-local interactions.</p> </li> <li> <p>Quantum Bayesianism (QBism)    The wavefunction represents an observer\u2019s subjective knowledge. Measurement outcomes are probabilistic, avoiding objective collapse.</p> </li> <li> <p>Relational Quantum Mechanics    Properties of a quantum system exist only relative to an observer or another system. Reality is observer-dependent, avoiding universal collapse.</p> </li> <li> <p>Objective Collapse Theories    Wavefunction collapse is a real, physical process independent of observation. Examples include GRW theory, which aims to bridge quantum and classical behavior.</p> </li> </ol> <p>Each interpretation addresses the role of measurement, the nature of reality, and the origins of randomness, highlighting the ongoing debate in quantum mechanics.</p>"},{"location":"Physics/pages/entanglement/#takeaways","title":"Takeaways","text":"<ol> <li> <p>Wavefunctions and Probabilities    Quantum states are represented by wavefunctions, with probabilities derived from their squared amplitudes. Particle decay exemplifies how these probabilities evolve over time.</p> </li> <li> <p>Momentum Conservation in Quantum Systems    Momentum conservation in particle decay allows properties of unobserved decay products to be inferred from observed ones, a crucial principle in particle physics.</p> </li> <li> <p>Entanglement and Non-Locality    Entangled particles share a combined quantum state, meaning the measurement of one instantly determines the state of the other, regardless of distance. This underpins phenomena like \"spooky action at a distance.\"</p> </li> <li> <p>The EPR Puzzle and Bell\u2019s Theorem    The EPR paradox challenges quantum mechanics with concepts like local realism, but Bell\u2019s Theorem confirms quantum mechanics\u2019 intrinsic non-locality, ruling out local hidden variable theories.</p> </li> <li> <p>Decoherence and the Quantum-Classical Divide    Decoherence explains how quantum systems lose their coherence through interaction with the environment, transitioning to classical-like behavior without requiring wavefunction collapse.</p> </li> <li> <p>Interpretations of Quantum Mechanics    Competing interpretations\u2014such as Copenhagen, Many-Worlds, and Pilot-Wave\u2014offer differing perspectives on measurement, reality, and randomness, reflecting the unresolved nature of quantum foundations.</p> </li> </ol>"},{"location":"Physics/pages/entanglement/#resources","title":"Resources","text":"<ol> <li>Quanta and Fields by Sean Carroll</li> </ol> &lt;- Measurement Fields -&gt;"},{"location":"Physics/pages/fields/","title":"Fields","text":"<p>From Sean Carroll's \"Quanta and Fields\" </p>"},{"location":"Physics/pages/fields/#key-concepts","title":"Key Concepts","text":""},{"location":"Physics/pages/fields/#1-fields-as-the-fabric-of-reality","title":"1. Fields as the Fabric of Reality","text":"<p>Fields, according to our best current understanding, are among the most fundamental ingredients of nature. In quantum field theory (QFT), particles emerge as excitations or quanta of underlying fields, rather than as independent entities moving through space.  </p> <ul> <li> <p>Not Just in Spacetime\u2014They Are Spacetime   Fields are not simply objects within spacetime; they constitute the dynamical degrees of freedom that fill all of spacetime. Efforts in quantum gravity suggest there may be something even deeper underlying these fields, but such ideas remain speculative.</p> </li> <li> <p>Debates in Interpretation   Just as quantum mechanics spurs debates about measurement and reality, QFT raises profound questions about fields, vacuum energy, and the structure of spacetime. Theoretical work continues to refine our understanding.</p> </li> </ul>"},{"location":"Physics/pages/fields/#2-qft-basics-and-the-role-of-the-hamiltonian","title":"2. QFT Basics and the Role of the Hamiltonian","text":"<p>In quantum theory, energy is introduced through the Hamiltonian, the operator that drives time evolution in the Schr\u00f6dinger equation. In QFT, every field has its own Hamiltonian, which dictates how the field behaves and what energies are allowed.</p> <ul> <li> <p>Energy of a Field   A field\u2019s Hamiltonian encodes both kinetic and potential energy terms. When the field is quantized, these translate into possible excitations of the field\u2014what we call \u201cparticles.\u201d</p> </li> <li> <p>Interaction vs. Free Fields </p> </li> <li>Free Fields:     Fields that do not interact with other fields or with themselves. Their Hamiltonian typically looks like a sum of non-interacting modes\u2014think of them as the simplest \u201cno forces\u201d scenario.  </li> <li>Interacting Fields:     In reality, fields often interact, introducing complexities like scattering, bound states, and nonlinear effects. These interactions make the theory rich\u2014and much more challenging.</li> </ul> <p>A common example for the Hamiltonian density \\(\\mathcal{H}\\) of a free scalar field \\(\\phi(\\mathbf{x}, t)\\) is:</p> \\[ \\mathcal{H} \\;=\\; \\frac{1}{2}\\,\\pi^2(\\mathbf{x}, t)  \\;+\\;\\frac{1}{2}\\,(\\nabla \\phi(\\mathbf{x}, t))^2  \\;+\\;\\frac{1}{2}\\,m^2\\,\\phi^2(\\mathbf{x}, t), \\] <p>where \\(\\pi(\\mathbf{x}, t)\\) is the conjugate momentum to \\(\\phi(\\mathbf{x}, t)\\). Integrating this over all space gives the total Hamiltonian \\(H\\).</p>"},{"location":"Physics/pages/fields/#3-free-fields-and-mass","title":"3. Free Fields and Mass","text":"<p>Free fields have no interaction potential. They spread out over space instead of being localized to a particular region. Even if a free field is said to carry \u201cmass,\u201d it does not automatically localize the field itself. Instead, the mass term in the Hamiltonian affects how excitations (particles) of the field propagate or decay.</p> <ul> <li>Why 'Mass' Still Matters   In QFT, \u201cmass\u201d determines the dispersion relation of excitations\u2014how the energy relates to momentum:</li> </ul> <p>$$   E^2 \\;=\\; \\mathbf{p}^2c^2 \\;+\\; m^2c^4.   $$</p> <p>A massive particle\u2019s energy depends differently on momentum than a massless particle\u2019s (like a photon). Nevertheless, the field itself remains everywhere, with quanta that appear as localized excitations when observed.</p>"},{"location":"Physics/pages/fields/#4-modes-the-building-blocks-of-field-configurations","title":"4. Modes: The Building Blocks of Field Configurations","text":"<p>A powerful way to think about fields is by decomposing them into modes\u2014wave-like solutions that span all of space.</p> <ul> <li>Plane Waves   A free field can be represented as a superposition of plane waves with different wavevectors \\(\\mathbf{k}\\). Mathematically, one common expression is:</li> </ul> <p>$$   \\phi(\\mathbf{x}, t)    \\;=\\; \\int \\frac{d^3k}{(2\\pi)^3} \\,\\Big[\\,      a_{\\mathbf{k}}\\,e^{\\,i(\\mathbf{k}\\cdot\\mathbf{x} \\;-\\; \\omega_{\\mathbf{k}}\\,t)}      \\;+\\;      a_{\\mathbf{k}}^*\\,e^{-\\,i(\\mathbf{k}\\cdot\\mathbf{x} \\;-\\; \\omega_{\\mathbf{k}}\\,t)}   \\Big],   $$</p> <p>where \\(\\omega_{\\mathbf{k}} = \\sqrt{\\mathbf{k}^2 + m^2}\\) for a scalar field (in units where \\(c = 1\\)).</p> <ul> <li> <p>Fourier Transform and \\(\\mathbf{k}\\)-Space   Going from real space \\(\\mathbf{x}\\) to momentum space \\(\\mathbf{k}\\) via the Fourier transform simplifies the mathematics of wave propagation and lays the groundwork for quantization.  </p> </li> <li> <p>Energy of a Mode   For a free scalar field, each \\(\\mathbf{k}\\)-mode behaves like a harmonic oscillator with energy levels spaced by \\(\\hbar \\omega_{\\mathbf{k}}\\). This fact underlies the idea that a free quantum field is essentially an infinite collection of quantum harmonic oscillators.</p> </li> </ul>"},{"location":"Physics/pages/fields/#5-wavefunctions-of-fields","title":"5. Wavefunctions of Fields","text":"<p>When multiple particles or excitations are possible, we no longer have just a \u201cwavefunction of one particle\u2019s position.\u201d Instead, we talk about a wavefunction over field configurations:</p> <ul> <li> <p>Configuration Space   The \u201cposition\u201d variable in standard quantum mechanics is replaced by the entire configuration of the field at each point in space. Formally, you might write a wavefunctional \\(\\Psi[\\phi]\\), which assigns amplitudes to every possible shape (configuration) of the field \\(\\phi\\).</p> </li> <li> <p>No Single-Particle Restriction   This viewpoint naturally accommodates different particle numbers\u2014one, two, or many excitations\u2014without needing separate wavefunctions for each possible number of particles.</p> </li> </ul>"},{"location":"Physics/pages/fields/#6-particles-from-fields-preview","title":"6. Particles from Fields (Preview)","text":"<p>While this chapter focuses on fields themselves, the notion of \u201cparticle\u201d arises when a field is excited in quantized energy levels (the modes). QFT unifies the idea of wave-particle duality: both wave-like and particle-like pictures emerge from the same underlying field.</p> <ul> <li>Creation and Annihilation Operators (Preview)   In a rigorous formulation, each mode \\(\\mathbf{k}\\) is treated as a quantized harmonic oscillator. We introduce operators \\(\\hat{a}^\\dagger_{\\mathbf{k}}\\) (creation) and \\(\\hat{a}_{\\mathbf{k}}\\) (annihilation) that raise or lower the number of quanta in that mode. For example, you might see:</li> </ul> <p>$$   \\hat{\\phi}(\\mathbf{x})    \\;=\\; \\int \\frac{d^3k}{(2\\pi)^3} \\,\\frac{1}{\\sqrt{2\\,\\omega_{\\mathbf{k}}}}    \\Big(!     \\hat{a}{\\mathbf{k}}\\,e^{\\,i\\,\\mathbf{k}\\cdot \\mathbf{x}}      \\;+\\;      \\hat{a}{\\mathbf{k}}^\\dagger\\,e^{-\\,i\\,\\mathbf{k}\\cdot \\mathbf{x}}   \\Big).   $$</p> <p>We\u2019ll see how these operators formalize the link between fields and particles in upcoming sections.</p>"},{"location":"Physics/pages/fields/#7-fields-of-the-world","title":"7. Fields of the World","text":"<p>Every known fundamental particle corresponds to a quantum field: electrons (electron field), photons (electromagnetic field), quarks (quark field), gluons (gluon field), and so on. Each field plays a role in the grand tapestry we call the Standard Model of particle physics.</p> <ul> <li>Speculative Frontiers   The quest for quantum gravity and the nature of spacetime continues to drive research. Whether fields themselves are emergent from deeper structures\u2014like strings, loops, or something else\u2014remains an active area of exploration.</li> </ul>"},{"location":"Physics/pages/fields/#takeaways","title":"Takeaways","text":"<ol> <li> <p>Fields Are Primary    In QFT, fields underpin the dynamics and properties of what we observe as \u201cparticles.\u201d The concept of an isolated particle traveling through space is replaced by the concept of excitations in a field permeating the entire universe.</p> </li> <li> <p>The Hamiltonian Defines Energy    The Hamiltonian for a field controls its evolution over time, just as in ordinary quantum mechanics. For free fields, it resembles an infinite collection of harmonic oscillators, each mode providing a quantized energy level.</p> </li> <li> <p>Modes and Superposition    By decomposing fields into plane-wave modes, we reveal how excitations form and propagate. The Fourier transform is central to this picture, illustrating how fields can be built up from an infinite set of simpler wave components.</p> </li> <li> <p>Wavefunctions Over Field Configurations    Instead of merely tracking the position of a single particle, QFT uses wavefunctionals that assign amplitudes to every conceivable field shape. This naturally incorporates situations with variable particle numbers.</p> </li> <li> <p>Linking Fields and Particles    \u201cParticles\u201d are best seen as discrete excitations of underlying fields, with creation and annihilation operators formalizing their quantum behavior. Future sections will explore how interactions shape these excitations, including scattering processes and bound states.</p> </li> <li> <p>Speculative Depths    While QFT is incredibly successful, many open questions remain\u2014especially about gravity and spacetime. We continue to explore whether fields are truly fundamental or themselves emergent from an even deeper theory.</p> </li> </ol>"},{"location":"Physics/pages/fields/#resources","title":"Resources","text":"<ol> <li>Quanta and Fields by Sean Carroll </li> <li>Peskin &amp; Schroeder, An Introduction to Quantum Field Theory </li> <li>David Tong, Lectures on Quantum Field Theory </li> </ol> &lt;- Entanglement Particles -&gt;"},{"location":"Physics/pages/measurement/","title":"Measurement","text":"<p>Based off Sean Carroll's \"Quantum and Fields\"</p>"},{"location":"Physics/pages/measurement/#key-concepts","title":"Key Concepts","text":""},{"location":"Physics/pages/measurement/#1-quantum-measurement","title":"1. Quantum Measurement","text":"<ul> <li>Measurement in quantum mechanics fundamentally differs from classical systems.</li> <li>Observables are represented by operators, and their outcomes are eigenvalues of these operators.</li> <li>The Born Rule describes the probability of measurement outcomes:   $$ P(a_i) = |\\langle \\psi | a_i \\rangle|^2 $$</li> <li>\\(P(a_i)\\): Probability of observing eigenvalue \\(a_i\\).</li> <li>Measurement collapses the wavefunction \\(\\psi\\) to the eigenstate \\(|a_i\\rangle\\).</li> </ul>"},{"location":"Physics/pages/measurement/#2-wavefunction-collapse-and-quantum-indeterminism","title":"2. Wavefunction Collapse and Quantum Indeterminism","text":"<ul> <li>Quantum Indeterminism: Outcomes in quantum mechanics are probabilistic rather than deterministic.</li> <li>The wavefunction (\\(\\psi\\)) encodes the probabilities of all possible measurement outcomes.</li> <li>Measurement changes the wavefunction, reducing it to the observed eigenstate (collapse).</li> </ul>"},{"location":"Physics/pages/measurement/#3-wave-particle-duality-and-the-double-slit-experiment","title":"3. Wave-Particle Duality and the Double-Slit Experiment","text":"<ul> <li>Wave-Particle Duality: Particles like photons and electrons exhibit both wave-like and particle-like behavior.</li> <li>Double-Slit Experiment:</li> <li>Without observation: Particles pass through both slits as waves, creating an interference pattern.</li> <li>With observation: Particles act as discrete entities, and the interference pattern disappears.</li> </ul> <p>Implications:   - Demonstrates quantum superposition and indeterminism.   - Measurement changes the behavior of the system.</p>"},{"location":"Physics/pages/measurement/#4-the-reality-problem","title":"4. The Reality Problem","text":"<ul> <li>The \"reality problem\" addresses whether the wavefunction represents:</li> <li>Physical Reality: A real entity in the universe.</li> <li>Epistemic Reality: A mathematical tool for calculating probabilities.</li> </ul> <p>Key Interpretations:   - Copenhagen Interpretation: The wavefunction collapses upon measurement.   - Many-Worlds Interpretation: No collapse occurs; all outcomes exist in parallel universes.</p>"},{"location":"Physics/pages/measurement/#5-hilbert-space","title":"5. Hilbert Space","text":"<ul> <li>A Hilbert Space is the mathematical framework for quantum states.</li> <li>Each quantum state is represented as a vector in this abstract space.</li> <li>Operators (e.g., position, momentum) act on these vectors to predict outcomes.</li> </ul> <p>Key Properties:   - Infinite-dimensional for continuous variables.   - Inner product (\\(\\langle \\psi_1 | \\psi_2 \\rangle\\)) defines probabilities and orthogonality.</p> <p>Differences from Classical Space-Time:   - Nature:     - Classical space-time describes the physical geometry of the universe.     - Hilbert space is an abstract mathematical space for quantum states.   - Dimensionality:     - Classical space-time: Finite (3 spatial + 1 temporal).     - Hilbert space: Potentially infinite-dimensional.   - Purpose:     - Classical space-time locates objects in the physical universe.     - Hilbert space provides a framework for predicting quantum outcomes.   - Structure:     - Hilbert space is linear, allowing superposition.     - Classical space-time is not inherently linear in this sense.</p>"},{"location":"Physics/pages/measurement/#6-qubits","title":"6. Qubits","text":"<ul> <li>A qubit is the quantum analog of a classical bit, represented as a superposition of two basis states:</li> </ul> <p>$$ |\\psi\\rangle = \\alpha|0\\rangle + \\beta|1\\rangle $$   where \\(\\alpha\\) and \\(\\beta\\) are complex coefficients satisfying \\(|\\alpha|^2 + |\\beta|^2 = 1\\).</p> <ul> <li>Measurement collapses the qubit state to either \\(|0\\rangle\\) or \\(|1\\rangle\\) with probabilities \\(|\\alpha|^2\\) and \\(|\\beta|^2\\).</li> </ul>"},{"location":"Physics/pages/measurement/#7-operators-and-observables","title":"7. Operators and Observables","text":"<ul> <li>Operators correspond to measurable quantities (e.g., position, momentum, spin).</li> <li> <p>Commutation relations determine compatibility:   $$ [\\hat{A}, \\hat{B}] = \\hat{A}\\hat{B} - \\hat{B}\\hat{A} $$</p> </li> <li> <p>Compatible Observables: \\([\\hat{A}, \\hat{B}] = 0\\) (can be measured simultaneously).</p> </li> <li>Incompatible Observables: \\([\\hat{A}, \\hat{B}] \\neq 0\\).</li> </ul>"},{"location":"Physics/pages/measurement/#8-uncertainty-principle","title":"8. Uncertainty Principle","text":"<ul> <li>The Heisenberg Uncertainty Principle limits simultaneous knowledge of conjugate variables, such as position (\\(x\\)) and momentum (\\(p\\)):</li> </ul> <p>Formula:   $$ \\Delta x \\cdot \\Delta p \\geq \\frac{\\hbar}{2} $$</p> <ul> <li>\\(\\Delta x\\): Uncertainty in position.  </li> <li>\\(\\Delta p\\): Uncertainty in momentum.</li> </ul> <p>Explanation:   - This arises from the wave-like nature of quantum systems and the Fourier transform.   - Measuring the wavefunction's position-space representation increases uncertainty in its momentum-space representation, and vice versa.   - For an intuitive understanding, see 3Blue1Brown's video on the uncertainty principle.</p>"},{"location":"Physics/pages/measurement/#9-momentum-and-measurement","title":"9. Momentum and Measurement","text":"<ul> <li> <p>Momentum is a fundamental observable in quantum mechanics, represented by the operator:   $$ \\hat{p} = -i\\hbar \\frac{\\partial}{\\partial x} $$</p> </li> <li> <p>Measuring momentum collapses the wavefunction to a momentum eigenstate.</p> </li> </ul>"},{"location":"Physics/pages/measurement/#important-examples","title":"Important Examples","text":""},{"location":"Physics/pages/measurement/#spin-measurement","title":"Spin Measurement","text":"<ul> <li>Measuring spin along an axis collapses the state to \\(|+\\rangle\\) or \\(|-\\rangle\\).</li> <li>Spin measurements along different axes (e.g., \\(x, y, z\\)) are incompatible.</li> </ul>"},{"location":"Physics/pages/measurement/#double-slit-experiment","title":"Double-Slit Experiment","text":"<ul> <li>Demonstrates quantum superposition and the role of measurement.</li> </ul>"},{"location":"Physics/pages/measurement/#position-and-momentum","title":"Position and Momentum","text":"<ul> <li>Conjugate variables governed by the uncertainty relation \\(\\Delta x \\cdot \\Delta p \\geq \\frac{\\hbar}{2}\\).</li> </ul>"},{"location":"Physics/pages/measurement/#takeaways","title":"Takeaways","text":"<ol> <li>Measurement is central to quantum mechanics, introducing probabilities and wavefunction collapse.</li> <li>Observables are tied to operators; outcomes depend on eigenvalues and eigenstates.</li> <li>The uncertainty principle and wave-particle duality highlight the unique nature of quantum systems.</li> <li>The double-slit experiment exemplifies quantum indeterminism and the measurement problem.</li> <li>Hilbert space provides the mathematical framework for quantum mechanics.</li> </ol>"},{"location":"Physics/pages/measurement/#resources","title":"Resources","text":"<ol> <li>Quanta and Fields by Sean Carroll</li> <li>3Blue1Brown's video on the uncertainty principle</li> </ol> &lt;- Wave Function Entanglement -&gt;"},{"location":"Physics/pages/waveFunction/","title":"Schr\u00f6dinger equation","text":"<p>The Schr\u00f6dinger equation is the cornerstone of quantum mechanics. It describes how the wave function of a quantum system evolves over time:</p> \\[ i \\hbar \\frac{\\partial \\psi}{\\partial t} = \\hat{H} \\psi \\] <ul> <li><code>i</code> is the imaginary unit (\u221a-1),</li> <li><code>\u210f</code> is the reduced Planck\u2019s constant,</li> <li><code>\u03c8(x, t)</code> is the wave function, representing the quantum state of the system,</li> <li><code>\u0124</code> is the Hamiltonian operator, representing the total energy of the system (kinetic + potential).</li> </ul>"},{"location":"Physics/pages/waveFunction/#the-wave-function","title":"The Wave Function","text":"<p>The Wave Function, <code>\u03c8(x, t)</code>, is a complex-valued function that encapsulates all the information about a quantum system. It serves as a mathematical representation of the particle's quantum state, containing information about properties such as position, momentum, and energy.</p> <p>The absolute value squared of the wave function, <code>|\u03c8(x, t)|^2</code>, is interpreted as the probability density of finding a particle at position <code>x</code> and time <code>t</code>. This interpretation was introduced by Max Born and is central to the probabilistic nature of quantum mechanics.</p> <p>Key points about the absolute value:</p> <ul> <li>Probability Density: <code>|\u03c8(x, t)|^2</code> represents the likelihood of locating a particle in a specific region of space. For example, in one dimension, the probability of finding the particle between positions <code>a</code> and <code>b</code> is given by:   $$   P(a \\leq x \\leq b) = \\int_a^b |\u03c8(x, t)|^2 dx   $$  </li> <li>Normalization: The total probability of finding the particle in all space must be 1. This imposes the normalization condition:   $$   \\int_{-\\infty}^{\\infty} |\u03c8(x, t)|^2 dx = 1   $$</li> <li>Interpretation: While the wave function itself is a complex number, only its absolute value squared has a physical interpretation.</li> </ul>"},{"location":"Physics/pages/waveFunction/#the-hamiltonian","title":"The Hamiltonian","text":"<p>The Hamiltonian operator, <code>\u0124</code>, defines the total energy of a quantum system and can take different forms depending on the system being studied. Some common examples include:</p> <ol> <li>Free Particle:    $$    \\hat{H} = -\\frac{\\hbar^2}{2m} \\nabla^2    $$</li> <li> <p>Represents a particle with no potential energy, only kinetic energy.</p> </li> <li> <p>Particle in a Potential:    $$    \\hat{H} = -\\frac{\\hbar^2}{2m} \\nabla^2 + V(x)    $$</p> </li> <li> <p>Includes a potential energy term, <code>V(x)</code>.</p> </li> <li> <p>Harmonic Oscillator:    $$    \\hat{H} = -\\frac{\\hbar^2}{2m} \\nabla^2 + \\frac{1}{2} m \\omega^2 x^2    $$</p> </li> <li> <p>Describes systems like vibrating molecules or quantum springs.</p> </li> <li> <p>Hydrogen Atom:    $$    \\hat{H} = -\\frac{\\hbar^2}{2m} \\nabla^2 - \\frac{e^2}{4 \\pi \\epsilon_0 r}    $$</p> </li> <li>Models the interaction between an electron and a proton.</li> </ol> <p>The form of the Hamiltonian determines the dynamics of the quantum system and governs the evolution of the wave function over time.</p>"},{"location":"Physics/pages/waveFunction/#a-brief-history-of-the-development-of-the-wave-function","title":"A Brief History of the Development of the Wave Function","text":"<p>Light as a Wave</p> <ul> <li>Christiaan Huygens (1678): Proposed the wave theory of light, suggesting that light travels as waves, contrary to Isaac Newton's particle theory.</li> <li>Thomas Young (1801): Demonstrated light's wave nature through the double-slit experiment, revealing interference patterns.</li> <li>Augustin-Jean Fresnel (1816): Expanded on Huygens' principle, mathematically explaining diffraction and interference.</li> </ul> <p>Electromagnetism and Light</p> <ul> <li>Michael Faraday (1831): Introduced the concept of electromagnetic fields, showing the interplay between electricity and magnetism.</li> <li>James Clerk Maxwell (1861\u20131865): Unified electricity, magnetism, and optics with Maxwell's equations, proving light to be an electromagnetic wave.</li> </ul> <p>The Atom and Subatomic Discoveries</p> <ul> <li>John Dalton (1803): Proposed that matter is composed of indivisible atoms.</li> <li>Dmitri Mendeleev (1869): Developed the periodic table, emphasizing the discrete properties of elements.</li> <li>J.J. Thomson (1897): Discovered the electron, introducing subatomic particles to atomic theory.</li> <li>Ernest Rutherford (1911): Conducted the gold foil experiment, leading to the nuclear model of the atom with a dense nucleus surrounded by electrons. This model raised questions about electron stability and atomic spectra.</li> </ul> <p>Blackbody Radiation and Quantization</p> <ul> <li>Max Planck (1900): Solved the blackbody radiation problem by introducing energy quantization: \\(\\(E = h \\nu\\)\\) , where <code>h</code> is Planck's constant and <code>v</code> is the frequency.</li> <li>Albert Einstein (1905): Explained the photoelectric effect using quantized light particles (photons), supporting the wave-particle duality of light.</li> </ul> <p>Atomic Spectra and Discrete Energy Levels</p> <ul> <li>Niels Bohr (1913): Introduced the Bohr model, explaining hydrogen's spectral lines via quantized electron orbits.</li> </ul> <p>Wave-Particle Duality</p> <ul> <li> <p>Louis de Broglie (1924): Proposed that matter exhibits wave-like behavior, with a wavelength given by:   $$   \\lambda = \\frac{h}{p}   $$   where <code>p</code> is the momentum.</p> </li> <li> <p>Albert Einstein (1905): Demonstrated the particle-like behavior of light through the photoelectric effect, showing that light is made up of discrete packets of energy called photons.</p> </li> <li> <p>Werner Heisenberg (1927): Introduced the uncertainty principle, which states that certain pairs of physical properties, such as position and momentum, cannot be simultaneously measured with arbitrary precision.</p> </li> </ul> <p>Schr\u00f6dinger\u2019s Equation</p> <ul> <li>Erwin Schr\u00f6dinger (1926): Developed the wave equation to describe quantum systems. The wave function \\(\\psi(x, t)\\) represents the quantum state of a particle and evolves according to:   $$   i \\hbar \\frac{\\partial \\psi}{\\partial t} = \\hat{H} \\psi   $$   where \\(\\hat{H}\\) is the Hamiltonian operator. Schr\u00f6dinger's work explained atomic phenomena such as electron orbitals.</li> </ul> <p>Interpretation of the Wave Function</p> <ul> <li>Max Born (1926): Interpreted \\(\\psi\\) as a probability amplitude, with \\(|\\psi|^2\\) giving the probability density of finding a particle in a given state. This marked a departure from deterministic classical mechanics.</li> </ul> <p>Complementarity and Uncertainty</p> <ul> <li>Werner Heisenberg (1927): Formulated the uncertainty principle, limiting the simultaneous measurement of properties like position and momentum.</li> <li>Niels Bohr: Advocated for complementarity, asserting the dual wave-particle nature of quantum systems.</li> </ul>"},{"location":"Physics/pages/waveFunction/#blackbody-thermal-radiation-problem-and-its-solution","title":"Blackbody (Thermal) Radiation Problem and Its Solution","text":"<p>The Blackbody Radiation Problem</p> <p>Blackbody radiation refers to the electromagnetic radiation emitted by an idealized object that absorbs all incident radiation, regardless of wavelength or angle. This object, called a blackbody, emits radiation solely based on its temperature. By the late 19th century, experimental studies of blackbody radiation revealed discrepancies that classical physics could not explain.</p> <p>Classical Predictions</p> <ul> <li>Rayleigh-Jeans Law: Classical physics, using the equipartition theorem, predicted that the intensity of blackbody radiation at short wavelengths (high frequencies) would grow infinitely, leading to what became known as the ultraviolet catastrophe. Mathematically, the intensity \\( I(\\nu, T) \\) was given by: $$ I(\\nu, T) = \\frac{8 \\pi \\nu^2}{c^3} k_B T $$</li> </ul> <p>Where: - \u03bd: Frequency of radiation - c: Speed of light - k_B: Boltzmann constant - T: Temperature of the blackbody</p> <p>This equation worked well at long wavelengths (low frequencies) but diverged at high frequencies, predicting an infinite energy output, which was physically impossible.</p> <p>Experimental Results</p> <p>Experimental data showed that the radiation intensity increased with frequency, peaked at a certain value, and then declined at higher frequencies. Classical theories failed to reproduce this behavior, prompting the need for a new explanation.</p> <p></p> <p>Source: LibreTexts Chemistry - Blackbody Radiation Cannot Be Explained Classically</p> <p>The Solution by Max Planck</p> <p>In 1900, Max Planck proposed a revolutionary solution that marked the birth of quantum theory. Planck introduced the idea that energy is not continuous but quantized. He suggested that electromagnetic radiation is emitted or absorbed in discrete packets, called quanta, with energy: $$ E = h \\nu $$ where: - h: Planck's constant (\\(6.626 \\times 10^{-34} \\, \\text{Js}\\)) - v: Frequency of radiation</p> <p>Planck\u2019s Law</p> <p>Using this assumption, Planck derived an equation that accurately described the observed blackbody radiation spectrum: $$ I(\\nu, T) = \\frac{8 \\pi h \\nu^3}{c^3} \\frac{1}{e^{\\frac{h \\nu}{k_B T}} - 1} $$ This equation successfully matched experimental data at all wavelengths, resolving the ultraviolet catastrophe.</p> <p>Implications of Planck's Solution</p> <ol> <li>Quantization of Energy: Planck's hypothesis introduced the concept of quantized energy levels, fundamentally challenging the continuous energy assumptions of classical physics.</li> <li>Wave-Particle Duality: The idea of energy quanta set the stage for the later development of wave-particle duality, where light and matter exhibit both wave-like and particle-like properties.</li> <li>Foundation of Quantum Mechanics: Planck\u2019s work paved the way for subsequent discoveries in quantum theory, including the photoelectric effect (Einstein), matter waves (de Broglie), and the wave function (Schr\u00f6dinger).</li> </ol>"},{"location":"Physics/pages/waveFunction/#particles-acting-like-waves-and-waves-acting-like-particles","title":"Particles Acting Like Waves and Waves Acting Like Particles","text":"<p>The development of quantum mechanics was heavily influenced by the realization that particles can exhibit wave-like behavior, and waves can exhibit particle-like behavior. This duality challenged the traditional boundaries between particles and waves in classical physics and became a cornerstone of quantum mechanics.</p>"},{"location":"Physics/pages/waveFunction/#waves-acting-like-particles","title":"Waves Acting Like Particles","text":"<p>Photoelectric Effect</p> <ul> <li>Discovery: The photoelectric effect demonstrated that light behaves like discrete packets of energy, called photons, rather than a continuous wave.</li> <li>Albert Einstein (1905): Explained that when light of sufficient frequency strikes a metal surface, it ejects electrons. This effect could not be explained by the wave theory of light, which predicted that energy would depend on the intensity of the light rather than its frequency.</li> <li>Key Equation: Einstein's explanation relied on the quantization of light energy:   $$   E = h \\nu   $$   where:</li> <li><code>E</code> is the energy of a photon,</li> <li><code>h</code> is Planck's constant, and</li> <li><code>\u03bd</code> is the frequency of light.</li> <li>Significance: This discovery provided direct evidence of the particle nature of light and introduced the concept of photons, supporting the idea of wave-particle duality.</li> </ul> <p>Compton Scattering</p> <ul> <li>Arthur Compton (1923): Showed that X-rays scattered off electrons exhibit changes in wavelength consistent with treating X-rays as particles (photons) colliding with electrons. This reinforced the particle-like behavior of waves.</li> </ul>"},{"location":"Physics/pages/waveFunction/#particles-acting-like-waves","title":"Particles Acting Like Waves","text":"<p>de Broglie's Hypothesis</p> <ul> <li>Louis de Broglie (1924): Proposed that matter, like light, exhibits wave-like properties. He introduced the concept of matter waves, with the wavelength of a particle given by:   $$   \\lambda = \\frac{h}{p}   $$   where:</li> <li><code>\u03bb</code> is the wavelength of the particle,</li> <li><code>h</code> is Planck's constant, and</li> <li><code>p</code> is the momentum of the particle.</li> <li>Implications: This hypothesis suggested that all particles, including electrons, have associated wave properties, which was later confirmed experimentally.</li> </ul> <p>Electron Diffractio</p> <ul> <li>Davisson-Germer Experiment (1927): Demonstrated the wave-like behavior of electrons by showing that they produce diffraction patterns when scattered off a crystal. This experiment provided direct evidence of de Broglie's matter waves.</li> </ul>"},{"location":"Physics/pages/waveFunction/#wave-particle-duality","title":"Wave-Particle Duality","text":"<p>Wave-particle duality is the principle that particles and waves exhibit both wave-like and particle-like properties depending on the experiment: - For Light: Light behaves as a wave in phenomena like interference and diffraction, but as particles (photons) in phenomena like the photoelectric effect. - For Matter: Particles like electrons behave as localized entities in some contexts but exhibit wave-like behavior, such as interference and diffraction, in others.</p>"},{"location":"Physics/pages/waveFunction/#impact-on-quantum-mechanics","title":"Impact on Quantum Mechanics","text":"<ol> <li>Quantum Theory of Radiation: The particle-like behavior of light and wave-like behavior of particles necessitated a new theory for describing phenomena at small scales.</li> <li>Wave Function: Schr\u00f6dinger\u2019s wave equation formalized the concept of wave-particle duality, describing particles as wave functions that evolve in time.</li> <li>Heisenberg's Uncertainty Principle: The duality introduced fundamental limits to simultaneously measuring properties like position and momentum:    $$    \\Delta x \\cdot \\Delta p \\geq \\frac{\\hbar}{2}    $$    where:</li> <li><code>\u0394x</code> is the uncertainty in position,</li> <li><code>\u0394p</code> is the uncertainty in momentum, and</li> <li><code>\u210f</code> is the reduced Planck's constant.</li> </ol>"},{"location":"Physics/pages/waveFunction/#resources","title":"Resources","text":"<ol> <li>LibreTexts Chemistry - Blackbody Radiation Cannot Be Explained Classically</li> <li>Quanta and Fields by Sean Carroll</li> </ol> &lt;- Overview Measurement -&gt;"},{"location":"SignalsSystems/pages/","title":"Overview","text":""},{"location":"SignalsSystems/pages/contTimeBasics/","title":"Continuous-Time Signals and Systems","text":""}]}